"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeNativeScript = exports.encodeLanguageViews = exports.encodePlutusData = exports.encodeAuxiliaryData = exports.encodeMetadata = exports.encodeWitnesses = exports.encodeVKeyWitness = exports.encodeCertificates = exports.encodeStakeDelegationCertificate = exports.encodeStakeDeRegistrationCertificate = exports.encodeStakeRegistrationCertificate = exports.encodeWithdrawals = exports.encodeOutputs = exports.encodeOutput = exports.encodeMint = exports.encodeOutputTokens = exports.encodeCollaterals = exports.encodeInputs = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */
/* eslint-disable no-use-before-define */
const buffer_1 = require("buffer");
const cbors = __importStar(require("@stricahq/cbors"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../types");
const helpers_1 = require("./helpers");
const crypto_1 = require("./crypto");
const internal_types_1 = require("../internal-types");
const encodeInputs = (inputs) => {
    const encodedInputs = inputs.map((input) => {
        const txHash = buffer_1.Buffer.from(input.txId, "hex");
        return [txHash, input.index];
    });
    return encodedInputs;
};
exports.encodeInputs = encodeInputs;
const encodeCollaterals = (collaterals) => {
    const encodedCollateralInputs = collaterals.map((collateral) => {
        const txHash = buffer_1.Buffer.from(collateral.txId, "hex");
        return [txHash, collateral.index];
    });
    return encodedCollateralInputs;
};
exports.encodeCollaterals = encodeCollaterals;
const encodeOutputTokens = (tokens) => {
    const policyIdMap = new Map();
    const tokenBundle = (0, lodash_1.default)(tokens)
        .groupBy(({ policyId }) => policyId)
        .value();
    lodash_1.default.forEach(tokenBundle, (token, policyId) => {
        const tokenMap = new Map();
        token.forEach(({ assetName, amount }) => {
            tokenMap.set(buffer_1.Buffer.from(assetName, "hex"), amount);
        });
        policyIdMap.set(buffer_1.Buffer.from(policyId, "hex"), tokenMap);
    });
    return policyIdMap;
};
exports.encodeOutputTokens = encodeOutputTokens;
const encodeMint = (mints) => {
    const policyIdMap = new Map();
    for (const mint of mints) {
        const tokenMap = new Map();
        mint.assets.forEach(({ assetName, amount }) => {
            tokenMap.set(buffer_1.Buffer.from(assetName, "hex"), amount);
        });
        policyIdMap.set(buffer_1.Buffer.from(mint.policyId, "hex"), tokenMap);
    }
    return policyIdMap;
};
exports.encodeMint = encodeMint;
const encodeOutput = (output) => {
    const amount = output.tokens.length > 0 ? [output.amount, (0, exports.encodeOutputTokens)(output.tokens)] : output.amount;
    // Babbage era output with inline datum and refScript support
    const encodedOutput = new Map();
    encodedOutput.set(internal_types_1.OutputItemType.ADDRESS, output.address.getBytes());
    encodedOutput.set(internal_types_1.OutputItemType.VALUE, amount);
    const plutusDataHash = output.plutusDataHash
        ? buffer_1.Buffer.from(output.plutusDataHash, "hex")
        : undefined;
    if (plutusDataHash) {
        encodedOutput.set(internal_types_1.OutputItemType.DATUM_OPTION, [0, plutusDataHash]);
    }
    else if (output.plutusData) {
        const encodedPlutusData = cbors.Encoder.encode((0, exports.encodePlutusData)(output.plutusData));
        encodedOutput.set(internal_types_1.OutputItemType.DATUM_OPTION, [1, new cbors.CborTag(encodedPlutusData, 24)]);
    }
    let refScript;
    if (output.plutusScript) {
        if (output.plutusScript.type === types_1.PlutusScriptType.PlutusScriptV1) {
            refScript = [1, buffer_1.Buffer.from(output.plutusScript.cborHex, "hex")];
        }
        else if (output.plutusScript.type === types_1.PlutusScriptType.PlutusScriptV2) {
            refScript = [2, buffer_1.Buffer.from(output.plutusScript.cborHex, "hex")];
        }
    }
    else if (output.nativeScript) {
        const encodedNativeScript = cbors.Encoder.encode((0, exports.encodeNativeScript)(output.nativeScript));
        refScript = [0, encodedNativeScript];
    }
    if (refScript) {
        const refScriptCbor = cbors.Encoder.encode(refScript);
        encodedOutput.set(internal_types_1.OutputItemType.SCRIPT_REF, new cbors.CborTag(refScriptCbor, 24));
    }
    return encodedOutput;
};
exports.encodeOutput = encodeOutput;
const encodeOutputs = (outputs) => {
    const encodedOutputs = outputs.map((output) => {
        return (0, exports.encodeOutput)(output);
    }, []);
    return encodedOutputs;
};
exports.encodeOutputs = encodeOutputs;
const encodeWithdrawals = (withdrawals) => {
    const encodedWithdrawals = new Map();
    withdrawals.forEach((withdrawal) => {
        const stakingAddress = withdrawal.rewardAccount.getBytes();
        encodedWithdrawals.set(stakingAddress, withdrawal.amount);
    });
    return encodedWithdrawals;
};
exports.encodeWithdrawals = encodeWithdrawals;
const encodeStakeRegistrationCertificate = (certificate) => {
    const stakeKeyHash = certificate.stakeCredential.hash;
    const stakeCredential = [certificate.stakeCredential.type, stakeKeyHash];
    return [types_1.CertificateType.STAKE_REGISTRATION, stakeCredential];
};
exports.encodeStakeRegistrationCertificate = encodeStakeRegistrationCertificate;
const encodeStakeDeRegistrationCertificate = (certificate) => {
    const stakeKeyHash = certificate.stakeCredential.hash;
    const stakeCredential = [certificate.stakeCredential.type, stakeKeyHash];
    return [types_1.CertificateType.STAKE_DE_REGISTRATION, stakeCredential];
};
exports.encodeStakeDeRegistrationCertificate = encodeStakeDeRegistrationCertificate;
const encodeStakeDelegationCertificate = (certificate) => {
    const stakeKeyHash = certificate.stakeCredential.hash;
    const stakeCredential = [certificate.stakeCredential.type, stakeKeyHash];
    const poolHash = buffer_1.Buffer.from(certificate.poolHash, "hex");
    return [types_1.CertificateType.STAKE_DELEGATION, stakeCredential, poolHash];
};
exports.encodeStakeDelegationCertificate = encodeStakeDelegationCertificate;
const encodeCertificates = (certificates) => {
    const encodedCertificates = [];
    certificates.forEach((certificate) => {
        switch (certificate.certType) {
            case types_1.CertificateType.STAKE_REGISTRATION:
                encodedCertificates.push((0, exports.encodeStakeRegistrationCertificate)(certificate));
                break;
            case types_1.CertificateType.STAKE_DE_REGISTRATION:
                encodedCertificates.push((0, exports.encodeStakeDeRegistrationCertificate)(certificate));
                break;
            case types_1.CertificateType.STAKE_DELEGATION:
                encodedCertificates.push((0, exports.encodeStakeDelegationCertificate)(certificate));
                break;
            default:
                throw new Error("unsupported certificate type");
        }
    });
    return encodedCertificates;
};
exports.encodeCertificates = encodeCertificates;
const encodeVKeyWitness = (vKeyWitness) => {
    // create a map of unique v keys
    const vKeyMap = new Map();
    for (const vKey of vKeyWitness) {
        vKeyMap.set(vKey.publicKey.toString("hex"), vKey.signature);
    }
    const encodedVKeyWitness = [];
    for (const [vKey, sig] of vKeyMap) {
        encodedVKeyWitness.push([buffer_1.Buffer.from(vKey, "hex"), sig]);
    }
    return encodedVKeyWitness;
};
exports.encodeVKeyWitness = encodeVKeyWitness;
const encodeWitnesses = (vKeyWitness, inputs, plutusDataList, plutusScriptMap, nativeScripts, mints) => {
    const encodedWitnesses = new Map();
    if (vKeyWitness.length > 0) {
        encodedWitnesses.set(types_1.WitnessType.V_KEY_WITNESS, (0, exports.encodeVKeyWitness)(vKeyWitness));
    }
    const sortedInputs = lodash_1.default.orderBy(inputs, ["txId", "index"], ["asc", "asc"]);
    const sortedMints = lodash_1.default.orderBy(mints, ["policyId"], ["asc"]);
    const encodedRedeemers = [];
    const encodedPlutusDataMap = new Map();
    for (const d of plutusDataList) {
        const encodedPlutusData = (0, exports.encodePlutusData)(d);
        const edCbor = cbors.Encoder.encode(encodedPlutusData);
        const edHash = (0, crypto_1.hash32)(edCbor);
        encodedPlutusDataMap.set(edHash.toString("hex"), encodedPlutusData);
    }
    for (const [index, input] of sortedInputs.entries()) {
        if (input.redeemer) {
            const encodedPlutusData = (0, exports.encodePlutusData)(input.redeemer.plutusData);
            encodedRedeemers.push([
                internal_types_1.RedeemerTag.SPEND,
                index,
                encodedPlutusData,
                [input.redeemer.exUnits.mem, input.redeemer.exUnits.steps],
            ]);
        }
    }
    for (const [index, mint] of sortedMints.entries()) {
        if (mint.plutusScript && mint.redeemer) {
            const encodedPlutusData = (0, exports.encodePlutusData)(mint.redeemer.plutusData);
            encodedRedeemers.push([
                internal_types_1.RedeemerTag.MINT,
                index,
                encodedPlutusData,
                [mint.redeemer.exUnits.mem, mint.redeemer.exUnits.steps],
            ]);
        }
    }
    const encodedPlutusDataList = [];
    for (const [, encodedPlutusData] of encodedPlutusDataMap) {
        encodedPlutusDataList.push(encodedPlutusData);
    }
    const encodedPlutusScriptsV1 = [];
    const encodedPlutusScriptsV2 = [];
    for (const [script, scriptType] of plutusScriptMap) {
        if (scriptType === types_1.PlutusScriptType.PlutusScriptV1) {
            const pls = cbors.Decoder.decode(buffer_1.Buffer.from(script, "hex"));
            encodedPlutusScriptsV1.push(pls.value);
        }
        else if (scriptType === types_1.PlutusScriptType.PlutusScriptV2) {
            const pls = cbors.Decoder.decode(buffer_1.Buffer.from(script, "hex"));
            encodedPlutusScriptsV2.push(pls.value);
        }
        else {
            throw new Error("Unsupported PlutusScript Version");
        }
    }
    if (encodedPlutusScriptsV1.length) {
        encodedWitnesses.set(types_1.WitnessType.PLUTUS_SCRIPT_V1, encodedPlutusScriptsV1);
    }
    if (encodedPlutusScriptsV2.length) {
        encodedWitnesses.set(types_1.WitnessType.PLUTUS_SCRIPT_V2, encodedPlutusScriptsV2);
    }
    const encodedNativeScriptMap = new Map();
    for (const ns of nativeScripts) {
        const encodedNativeScript = (0, exports.encodeNativeScript)(ns);
        const nsCbor = cbors.Encoder.encode(encodedNativeScript);
        encodedNativeScriptMap.set(nsCbor.toString("hex"), encodedNativeScript);
    }
    const encodedNativeScripts = [];
    for (const [, encodedNS] of encodedNativeScriptMap) {
        encodedNativeScripts.push(encodedNS);
    }
    if (encodedNativeScripts.length) {
        encodedWitnesses.set(types_1.WitnessType.NATIVE_SCRIPT, encodedNativeScripts);
    }
    if (encodedPlutusDataList.length)
        encodedWitnesses.set(types_1.WitnessType.PLUTUS_DATA, encodedPlutusDataList);
    if (encodedRedeemers.length) {
        encodedWitnesses.set(types_1.WitnessType.REDEEMER, encodedRedeemers);
    }
    return encodedWitnesses;
};
exports.encodeWitnesses = encodeWitnesses;
const encodeMetadata = (metadataArray) => {
    const encodedMetadata = new Map();
    for (const metadata of metadataArray) {
        encodedMetadata.set(metadata.label, (0, helpers_1.sanitizeMetadata)(metadata.data));
    }
    return encodedMetadata;
};
exports.encodeMetadata = encodeMetadata;
const encodeAuxiliaryData = (auxiliaryData) => {
    const encodedMetadata = (0, exports.encodeMetadata)(auxiliaryData.metadata);
    const auxDataMap = new Map();
    auxDataMap.set(0, encodedMetadata);
    return new cbors.CborTag(auxDataMap, 259);
};
exports.encodeAuxiliaryData = encodeAuxiliaryData;
const PlutusDataObjectKeys = ["constructor", "fields"];
const createConstructor = (pConstructor) => {
    const keys = Object.keys(pConstructor);
    if (!(keys.every((val) => PlutusDataObjectKeys.includes(val)) &&
        pConstructor.fields instanceof Array)) {
        throw new Error("Invalid PlutusData supplied");
    }
    // array is definite length if empty
    let fields = [];
    if (pConstructor.fields.length > 0) {
        fields = new cbors.IndefiniteArray();
        for (const field of pConstructor.fields) {
            fields.push((0, exports.encodePlutusData)(field));
        }
    }
    if (pConstructor.constructor < 7) {
        return new cbors.CborTag(fields, 121 + pConstructor.constructor);
    }
    if (pConstructor.constructor > 6 && pConstructor.constructor < 128) {
        const mask = pConstructor.constructor - 7;
        return new cbors.CborTag(fields, 1280 + mask);
    }
    return new cbors.CborTag([pConstructor.constructor, fields], 102);
};
const encodePlutusData = (plutusData) => {
    if (plutusData instanceof Array) {
        if (plutusData.length > 0) {
            const ary = new cbors.IndefiniteArray();
            for (const d of plutusData) {
                ary.push((0, exports.encodePlutusData)(d));
            }
            return ary;
        }
        return [];
    }
    if (plutusData instanceof Uint8Array) {
        return buffer_1.Buffer.from(plutusData);
    }
    if (plutusData instanceof buffer_1.Buffer) {
        return plutusData;
    }
    if (typeof plutusData === "string") {
        throw new Error("String not supported in PlutusData");
    }
    // TODO: map is also an object, check map first, maybe requires a proper fix
    else if (plutusData instanceof Map) {
        if (plutusData.size > 0) {
            const map = new cbors.IndefiniteMap();
            for (const [key, value] of plutusData.entries()) {
                map.set(key, (0, exports.encodePlutusData)(value));
            }
            return map;
        }
        return new Map();
    }
    else if (bignumber_js_1.default.isBigNumber(plutusData)) {
        return plutusData;
    }
    else if (plutusData instanceof Object) {
        const constructorObject = plutusData;
        const constructor = createConstructor(constructorObject);
        return constructor;
    }
    else {
        return plutusData;
    }
};
exports.encodePlutusData = encodePlutusData;
const encodeLanguageViews = (languageView, plutusV1, plutusV2) => {
    const encodedLanguageView = new Map();
    if (plutusV1) {
        // The encoding is Plutus V1 Specific
        const costMdls = (0, lodash_1.default)(languageView.PlutusScriptV1)
            .map((value, key) => ({
            key,
            value,
        }))
            .orderBy(["key"], ["asc"])
            .map((item) => item.value)
            .value();
        // indefinite array encoding
        const indefCostMdls = cbors.IndefiniteArray.from(costMdls);
        // for V1, encode values before adding to view map
        const cborCostMdls = cbors.Encoder.encode(indefCostMdls);
        const langId = cbors.Encoder.encode(0);
        // Plutus V1
        encodedLanguageView.set(langId, cborCostMdls);
    }
    if (plutusV2) {
        // The encoding is Plutus V2 Specific
        const costMdls = (0, lodash_1.default)(languageView.PlutusScriptV1)
            .map((value, key) => ({
            key,
            value,
        }))
            .orderBy(["key"], ["asc"])
            .map((item) => item.value)
            .value();
        // Plutus V2
        encodedLanguageView.set(1, costMdls);
    }
    return cbors.Encoder.encode(encodedLanguageView).toString("hex");
};
exports.encodeLanguageViews = encodeLanguageViews;
const encodeNativeScripts = (nativeScripts) => {
    const encodedNativeScripts = [];
    for (const ns of nativeScripts) {
        encodedNativeScripts.push((0, exports.encodeNativeScript)(ns));
    }
    return encodedNativeScripts;
};
const encodeNativeScript = (nativeScript) => {
    if (nativeScript.pubKeyHash) {
        return [0, buffer_1.Buffer.from(nativeScript.pubKeyHash, "hex")];
    }
    if (nativeScript.all) {
        return [1, encodeNativeScripts(nativeScript.all)];
    }
    if (nativeScript.any) {
        return [2, encodeNativeScripts(nativeScript.any)];
    }
    if (nativeScript.n) {
        return [3, nativeScript.n, encodeNativeScripts(nativeScript.k)];
    }
    if (nativeScript.invalidBefore) {
        return [4, nativeScript.invalidBefore];
    }
    if (nativeScript.invalidAfter) {
        return [5, nativeScript.invalidAfter];
    }
    throw new Error("Invalid native script");
};
exports.encodeNativeScript = encodeNativeScript;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RewardAddress = void 0;
/* eslint-disable no-bitwise */
const buffer_1 = require("buffer");
const bech32_1 = require("bech32");
const types_1 = require("../types");
class RewardAddress {
    constructor(networkId, stakeCredential) {
        this.addressHex = "";
        this.addressBytes = buffer_1.Buffer.alloc(0);
        this.addressBech32 = "";
        this._stakeCredential = stakeCredential;
        this.networkId = networkId;
        this.computeHex();
    }
    computeBech32(address) {
        const data = this.networkId === types_1.NetworkId.MAINNET ? "stake" : "stake_test";
        const words = bech32_1.bech32.toWords(address);
        const encoded = bech32_1.bech32.encode(data, words, 1000);
        return encoded;
    }
    computeHex() {
        let payload = 224;
        if (this._stakeCredential.type === types_1.HashType.ADDRESS) {
            // set 4th bit to 0, which is set by default
        }
        else if (this._stakeCredential.type === types_1.HashType.SCRIPT) {
            const mask = 1 << 4;
            payload |= mask;
        }
        payload |= this.networkId;
        const address = `${payload.toString(16).padStart(2, "0")}${this._stakeCredential.hash.toString("hex")}`;
        this.addressHex = address;
        this.addressBytes = buffer_1.Buffer.from(address, "hex");
        this.addressBech32 = this.computeBech32(this.addressBytes);
    }
    get stakeCredential() {
        return this._stakeCredential;
    }
    getHex() {
        return this.addressHex;
    }
    getBytes() {
        return this.addressBytes;
    }
    getBech32() {
        return this.addressBech32;
    }
    getNetworkId() {
        return this.networkId;
    }
}
exports.RewardAddress = RewardAddress;
exports.default = RewardAddress;

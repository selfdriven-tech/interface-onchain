"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cbors_1 = require("@stricahq/cbors");
const bip32ed25519_1 = require("@stricahq/bip32ed25519");
const blakejs_1 = require("blakejs");
const buffer_1 = require("buffer");
class CoseSign1 {
    constructor(payload) {
        this.protectedMap = payload.protectedMap;
        this.unProtectedMap = payload.unProtectedMap;
        this.payload = payload.payload;
        if (this.unProtectedMap.get("hashed") == null) {
            this.unProtectedMap.set("hashed", false);
        }
        this.signature = payload.signature;
    }
    static fromCbor(cbor) {
        const decoded = cbors_1.Decoder.decode(buffer_1.Buffer.from(cbor, "hex"));
        if (!(decoded.value instanceof Array))
            throw Error("Invalid CBOR");
        if (decoded.value.length !== 4)
            throw Error("Invalid COSE_SIGN1");
        let protectedMap;
        // Decode and Set ProtectedMap
        const protectedSerialized = decoded.value[0];
        try {
            protectedMap = cbors_1.Decoder.decode(protectedSerialized).value;
            if (!(protectedMap instanceof Map)) {
                throw Error();
            }
        }
        catch (error) {
            throw Error("Invalid protected");
        }
        // Set UnProtectedMap
        const unProtectedMap = decoded.value[1];
        if (!(unProtectedMap instanceof Map))
            throw Error("Invalid unprotected");
        // Set Payload
        const payload = decoded.value[2];
        // Set Signature
        const signature = decoded.value[3];
        return new CoseSign1({
            protectedMap,
            unProtectedMap,
            payload,
            signature,
        });
    }
    createSigStructure(externalAad = buffer_1.Buffer.alloc(0)) {
        let protectedSerialized = buffer_1.Buffer.alloc(0);
        if (this.protectedMap.size !== 0) {
            protectedSerialized = cbors_1.Encoder.encode(this.protectedMap);
        }
        const structure = ["Signature1", protectedSerialized, externalAad, this.payload];
        return cbors_1.Encoder.encode(structure);
    }
    buildMessage(signature) {
        this.signature = signature;
        let protectedSerialized = buffer_1.Buffer.alloc(0);
        if (this.protectedMap.size !== 0) {
            protectedSerialized = cbors_1.Encoder.encode(this.protectedMap);
        }
        const coseSign1 = [protectedSerialized, this.unProtectedMap, this.payload, this.signature];
        return cbors_1.Encoder.encode(coseSign1);
    }
    verifySignature({ externalAad = buffer_1.Buffer.alloc(0), publicKeyBuffer, } = {}) {
        if (!publicKeyBuffer) {
            publicKeyBuffer = this.getPublicKey();
        }
        if (!publicKeyBuffer)
            throw Error("Public key not found");
        if (!this.signature)
            throw Error("Signature not found");
        const publicKey = new bip32ed25519_1.PublicKey(publicKeyBuffer);
        return publicKey.verify(this.signature, this.createSigStructure(externalAad));
    }
    hashPayload() {
        if (!this.unProtectedMap)
            throw Error("Invalid unprotected map");
        if (!this.payload)
            throw Error("Invalid payload");
        if (this.unProtectedMap.get("hashed"))
            throw Error("Payload already hashed");
        if (this.unProtectedMap.get("hashed") != false)
            throw Error("Invalid unprotected map");
        this.unProtectedMap.set("hashed", true);
        const hash = (0, blakejs_1.blake2b)(this.payload, undefined, 24);
        this.payload = buffer_1.Buffer.from(hash);
    }
    getAddress() {
        return this.protectedMap.get("address");
    }
    getPublicKey() {
        return this.protectedMap.get(4);
    }
    getSignature() {
        return this.signature;
    }
}
exports.default = CoseSign1;

/*
	Create metadata and transaction data 
    Based on JSON data - ie from entityos/entityos

	Supporting process:

	- Create/Mint Actions that have billingstatus = 1 (Billable) and set to billingstatus = 5 (Billed)
		"bill" as in "onchain asset" - latin "sealed document"

*/

var entityos = require('entityos');
var _ = require('lodash');

module.exports =
{
	VERSION: '0.0.1',

	init: function (param)
	{
		// Process actions

        entityos.add(
		{
			name: 'onchain-process-oncloud-actions',
			notes: 'Get actions that have billingstatus = 1 (Billable)',
			code: function (param, response)
			{
				if (response == undefined)
				{
					let actionTypes = _.get(param, 'actionTypes');
			
					if (actionTypes == undefined)
					{
						const event = entityos.get({scope: '_event'});
						actionTypes = _.get(event, 'actionTypes');
					}

					if (_.startsWith(actionTypes, 'setting:'))
					{
						// eg setting:selfdriven.actionTypes.achievements
						const settings = entityos.get({scope: '_settings'});
						const setting = _.replace(actionTypes, 'setting:', '');
						actionTypes = _.get(settings, setting);
					}

					if (actionTypes == undefined)
					{
						_.set(param, 'error', 'No Action Type(s) set.')
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.cloud.search(
						{
							object: 'action',
							fields: [{ name: 'guid' }],
							filters: 
							[
								{
									field: 'type',
									comparison: 'IN_LIST',
									value: actionTypes
								}
							],
							rows: 10,
							callback: 'onchain-process-oncloud-actions'
						});
					}
				}
				else
				{
					//JSON.parse(Buffer.from(event.body, 'base64').toString('utf-8'));

					entityos.set(
					{
						scope: 'onchain-process-oncloud-actions',
						context: 'actions',
						value: response.data.rows
					});

					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', {message: 'No actions to process.'})
					}
					else
					{
						entityos.invoke('onchain-process-oncloud-ssi-verifiable-credentials', param);
					}
				}  
			}	
		});	

		entityos.add(
		{
			name: 'onchain-process-oncloud-ssi-verifiable-credentials',
			notes: 'Get associated SSI data eg Verifiable Credential',
			code: function (param, response)
			{
				const settings = entityos.get({scope: '_settings'});

				if (response == undefined)
				{
					var actions = entityos.get(
					{
						scope: 'onchain-process-oncloud-actions',
						context: 'actions',
						valueDefault: []
					});

					var filters = [];

					if (actions.length != 0)
					{
						filters.push(
						{
							field: 'objectcontext',
							comparison: 'IN_LIST',
							value: _.join(_.map(actions, 'id'), ',')
						});
					}
					else
					{
						filters.push(
						{
							field: 'notes',
							comparison: 'EQUAL_TO',
							value: '[achievement-ssi-share-on-chain]'
						});
					}

					const octoSigningKeyID = _.get(settings, 'protect.sign.keyID');

					if (octoSigningKeyID != undefined)
					{
						filters.push(
						{
							field: 'key',
							comparison: 'EQUAL_TO',
							value: octoSigningKeyID
						});
					}

					entityos.cloud.search(
					{
						object: 'core_protect_ciphertext',
						fields: [{ name: 'sourcetext' }, { name: 'objectcontext' }],
						filters: filters,
						rows: 10,
						callback: 'onchain-process-oncloud-ssi-verifiable-credentials'
					});					
				}
				else
				{
					//JSON.parse(Buffer.from(event.body, 'base64').toString('utf-8'));

					entityos.set(
					{
						scope: 'onchain-process-oncloud-actions',
						context: 'ssi',
						value: response.data.rows
					})

					if (response.data.rows.length == 0)
					{}
					else
					{
						//console.log(response.data.rows)

						const cardanoSDAAsset = _.get(settings, 'onchain.cardano.assets.sda')

						_.each(response.data.rows, function (row)
						{
							row._ssiVC = JSON.parse(Buffer.from(row.sourcetext, 'base64').toString('utf-8'));

							console.log('_sdaOnChainData.' + cardanoSDAAsset.label + '.' + cardanoSDAAsset.policyID + '.SSI');

							row._sdaOnChainData = {};

							_.set(row._sdaOnChainData, cardanoSDAAsset.label + '.' + cardanoSDAAsset.policyID + '.SSI',
							{
								"id": row._ssiVC.id,
								"issuer": row._ssiVC.issuer,
								"proof": row._ssiVC.proof
							});

							console.log(JSON.stringify(row._sdaOnChainData, null, 2))
						});
					}
				}  
			}	
		});

		entityos.add(
		{
			name: 'onchain-process-transaction',
			code: function (param, response)
			{
				// Octo or User == Passed key.id for shared custody Cardano wallet/account

				// Get Cardano Protocol Parameters
				// Prepare transaction
				// Get the Octo Wallet Keys
				// Sign transaction
				// Submit transaction
				
				entityos.set({scope: 'onchain-process-transaction', value: {}});
				entityos.invoke('onchain-process-transaction-get-protocol-parameters');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-get-protocol-parameters',
			code: function (data)
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				if (dataProcessTransaction.protocolParameters == undefined)
				{
					const settings = entityos.get({scope: '_settings'});
					const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');

					if (blockfrostProjectID == undefined)
					{
						entityos.invoke('util-end',
						{
							error: 'No access to onchain data / indexing service. [indexer-service-api-key-not-set]'
						});
					}
					else
					{
						const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
						const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});
						
						//console.log(blockfrostAPI)

						blockfrostAPI.epochsLatestParameters().then(function (parameters)
						{
							parameters.minFeeA = parameters['min_fee_a'];
							parameters.minFeeB = parameters['min_fee_b'];

							parameters.priceMem = parameters['price_mem']
							parameters.priceSteps = parameters['price_step']

							entityos.set(
							{
								scope: 'onchain-process-transaction',
								context: 'protocolParameters',
								value: parameters
							});

							console.log(parameters)

							const _parameters = {
								linearFee: {
									minFeeA: _.toString(parameters['min_fee_a']),
									minFeeB: _.toString(parameters['min_fee_b']),
								},
								minUtxo: _.toString(parameters['min_utxo']),
								poolDeposit: _.toString(parameters['pool_deposit']),
								keyDeposit: _.toString(parameters['key_deposit']),
								maxTxSize: parseInt(parameters['max_tx_size']),
								maxValSize: parseInt(parameters['max_val_size']),
								coinsPerUtxoByte: parameters['coins_per_utxo_size']
							};

							console.log('_parameters');
							console.log(_parameters)

							entityos.set(
							{
								scope: 'onchain-process-transaction',
								context: '_protocolParameters',
								value: _parameters
							});

							entityos.invoke('onchain-process-transaction-prepare');
						})
						.catch(function (error)
						{
							console.log(error)
							entityos.invoke('util-end', {error: error.message})
						});
					}
				}
				else
				{
					entityos.invoke('onchain-process-transaction-prepare');
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare',
			code: function (param)
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});	
				
				//console.log(JSON.stringify(dataProcessTransaction.protocolParameters));

				// If Octo then these are the same.

				const settings = entityos.get({scope: '_settings'});
				const event = entityos.get({scope: '_event'});

				dataProcessTransaction.senderAddress = _.get(event, 'senderaddress');
				dataProcessTransaction.recieverAddress = _.get(event, 'recieveraddress');

				if (dataProcessTransaction.senderAddress == undefined)
				{
					dataProcessTransaction.senderAddress = _.get(settings, 'onchain.cardano.octo.addresses.transaction');
				}

				if (dataProcessTransaction.recieverAddress == undefined)
				{
					dataProcessTransaction.recieverAddress = _.get(settings, 'onchain.cardano.octo.addresses.transaction');
				}

				// Get UTXOs

				const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');

				const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
				const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});

				//console.log(blockfrostAPI)

				console.log(dataProcessTransaction.senderAddress)

				blockfrostAPI.addressesUtxos(dataProcessTransaction.senderAddress).then(function (utxos)
				{
					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'utxos',
						value: utxos
					});
					
					entityos.invoke('onchain-process-transaction-prepare-latest-slot');
				})
				.catch(function (error)
				{
					console.log(error)
					entityos.invoke('util-end', {error: error.message})
				});

				// Inputs
				// Outputs
				// Metadata
				// Get Key 
				// Submit
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-latest-slot',
			code: function (e)
			{
				const settings = entityos.get({scope: '_settings'});
				const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');
				const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
				const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});

				console.log(blockfrostAPI)

				blockfrostAPI.blocksLatest().then(function (data)
				{
					//console.log(data)
					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'latest-block',
						value: data
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'latest-slot',
						value: data.slot
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'ttl',
						value: data.slot + 7200 // 2 hours
					});
					
					entityos.invoke('onchain-process-transaction-prepare-utxos');
				})
				.catch(function (error)
				{
					console.log(error)
					entityos.invoke('util-end', {error: error.message})
				});
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-utxos',
			code: function (param, response)
			{
				let utxos = entityos.get(
				{
					scope: 'onchain-process-transaction',
					context: 'utxos'
				});

				//console.log(JSON.stringify(utxos, null, 2));

				const event = entityos.get({scope: '_event'});

				let sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					sendAmountLovelace = (sendAmountADA * 1000000);
				}

				_.each(utxos, function (utxo)
				{
					utxo._lovelaces = _.filter(utxo.amount, function (amount)
					{
						return (amount.unit == 'lovelace')
					});

					utxo.lovelace = _.sum(_.map(utxo._lovelaces, function (lovelace) {return parseInt(lovelace.quantity)}));
					utxo.ada = utxo.lovelace / 1000000;

					utxo.lovelaceOnly = (utxo.amount.length == 1);

					/*
						{
							"address": "addr1q98xcd2q35kgt9cl8pzj46ztgzkx5rrpt9xe97z3e5yxfdlrm5zhvgxwkfc0zwdywruts8waa4nkkh3x24z9taqhhqtsqrucn3",
							"tx_hash": "a130469699670bb6520ae4943fa9abb3a1d0bc0f1d0b627fb9f83ded5b14a018",
							"tx_index": 0,
							"output_index": 0,
							"amount": [
							{
								"unit": "lovelace",
								"quantity": "5000000"
							}
							],
							"block": "f6fda94f979547c6a40d10fb48b033127257e958d828ca8b17b5db42d8d90fd6",
							"data_hash": null,
							"inline_datum": null,
							"reference_script_hash": null
						}
					*/
				});

				//console.log(JSON.stringify(utxos, null, 2));

				const totalAmountLoveLace = _.sum(_.map(utxos, function (utxo) {return parseInt(utxo.lovelace)}));

				if (sendAmountLovelace > totalAmountLoveLace)
				{
					entityos.invoke('util-end',
					{
						error: 'Not enough lovelace (ADA) available.'
					});
				}
				else
				{
					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'totalAmountLoveLace',
						value: totalAmountLoveLace
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'utxos',
						value: utxos
					});

					entityos.invoke('onchain-process-transaction-prepare-inputs')
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-inputs',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				// Use up smaller utxos first as a form of consilidation

				dataProcessTransaction.utxos = _.sortBy(dataProcessTransaction.utxos, 'lovelace');

				const event = entityos.get({scope: '_event'});
				let sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					sendAmountLovelace = (sendAmountADA * 1000000);
				}

				sendAmountLovelace = parseInt(sendAmountLovelace);

				dataProcessTransaction.sendAmountLovelace = sendAmountLovelace;
				
				if (sendAmountLovelace == 0)
				{
					entityos.invoke('util-end',
					{
						error: 'Send amount is 0.'
					});
				}
				else
				{
					let utxosTotalLovelace = 0;
					let sendAmountLovelaceCovered = false;

					const settings = entityos.get({scope: '_settings'});

					let sendAmountLovelaceMinimum = _.get(settings, 'onchain.cardano.inputsminimumlovelace', 0);
					if (sendAmountLovelace > sendAmountLovelaceMinimum)
					{
						sendAmountLovelaceMinimum = sendAmountLovelace;
					}

					console.log('sendAmountLovelaceMinimum:' + sendAmountLovelaceMinimum)

					_.each(dataProcessTransaction.utxos, function (utxo)
					{
						utxosTotalLovelace = utxosTotalLovelace + utxo.lovelace;

						utxo.includeAsInput = false;

						if (!sendAmountLovelaceCovered)
						{
							utxo.includeAsInput = true;
							if (utxosTotalLovelace > sendAmountLovelaceMinimum)
							{
								sendAmountLovelaceCovered = true
							}
						}
					});

					dataProcessTransaction.utxoInputs = _.filter(dataProcessTransaction.utxos, function (utxo)
					{
						return utxo.includeAsInput
					});

					console.log(JSON.stringify(dataProcessTransaction.utxoInputs, null, 2));

					if (!sendAmountLovelaceCovered)
					{
						entityos.invoke('util-end',
						{
							error: 'Not enough available transactions as inputs.'
						});
					}
					else
					{
						dataProcessTransaction.inputs = [];

						const BigNumber = require('bignumber.js');
						const Cardano = require("@emurgo/cardano-serialization-lib-nodejs");

						dataProcessTransaction._senderAddress = Cardano.Address.from_bech32(dataProcessTransaction.senderAddress);
						dataProcessTransaction._recieverAddress = Cardano.Address.from_bech32(dataProcessTransaction.recieverAddress);

						console.log(JSON.stringify(dataProcessTransaction._senderAddress, null, 2))

						//dataProcessTransaction._senderAddressHash = _.get(dataProcessTransaction._senderAddress, '_paymentCredential.hash');
						
						_.each(dataProcessTransaction.utxoInputs, function (utxoInput)
						{
							//console.log(new BigNumber(utxoInput.lovelace));

							dataProcessTransaction.inputs.push(
							{
								txId: utxoInput.tx_hash,
								index: parseInt(utxoInput.tx_index),
								_amount: utxoInput.lovelace,
								amount: new BigNumber(utxoInput.lovelace),
								address: dataProcessTransaction._senderAddress,
								tokens: []
							});
						});

						//console.log(JSON.stringify(dataProcessTransaction.inputs, null, 2));
					
						entityos.invoke('onchain-process-transaction-prepare-outputs')
					}
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-outputs',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});
				const BigNumber = require('bignumber.js');

				dataProcessTransaction.outputs =
				[
					{
						address: dataProcessTransaction._recieverAddress,
						_amount: dataProcessTransaction.sendAmountLovelace,
						amount: new BigNumber(dataProcessTransaction.sendAmountLovelace)
					}
				]

				//console.log(JSON.stringify(dataProcessTransaction.outputs, null, 2));

				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-get-keys',
			code: function (data)
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				if (dataProcessTransaction.keys == undefined)
				{
					// if event keyaccount= provide then use that to look up core_protect_key
					// 	 Else get the Octo Wallet Keys for _settings based on ENV
					// Build private key from entropy or nmo

					const event = entityos.get({scope: '_event'});

					if (event.keyaccount != undefined)
					{
						//entityos.invoke('onchain-process-transaction-keys-from-account');
					}
					else
					{
						const settings = entityos.get({scope: '_settings'});
						
						let keysEntropy = _.get(settings, 'onchain.cardano.octo.entropy');

						console.log(keysEntropy)

						if (keysEntropy == undefined)
						{
							entityos.invoke('util-end',
							{
								error: 'No Octo key settings.'
							});
						}
						else
						{
							const Cardano = require("@emurgo/cardano-serialization-lib-nodejs");

							let keys = {};

							keys.root = Cardano.Bip32PrivateKey.from_bip39_entropy(
								Buffer.from(keysEntropy, 'hex'),
								Buffer.from(''),
							);

							//console.log(keys);

							keys.rootBech32 = keys.root.to_bech32()

							function harden(num)
							{
								return 0x80000000 + num;
							}	

							keys.account = keys.root
								.derive(harden(1852)) // purpose
								.derive(harden(1815)) // coin type
								.derive(harden(0)); // account #0

							keys._transaction = keys.account
								.derive(0) // external
								.derive(0);

							//keys._transactionKeyBech32 = keys._transactionKeyPrivate.to_bech32()

							keys._transactionPublic = keys._transaction
								.to_public();

							keys._stakeKey = keys.account
								.derive(2) // external
								.derive(0);

							keys.private = Cardano.Bip32PrivateKey.from_bech32(keys.rootBech32);
							keys.public = Cardano.Bip32PrivateKey.from_bech32(keys.rootBech32).to_public();
							//keys.publicHash = Cardano.PrivateKey.from_bech32(keys.rootBech32).to_public().hash()

							console.log(keys)

							entityos.set(
							{
								scope: 'onchain-process-transaction',
								context: 'keys',
								value: keys
							});

							//entityos.invoke('onchain-process-transaction-sign');
						}
					}
					
				}
				else
				{
					entityos.invoke('onchain-process-transaction-sign');
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-sign',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				const Cardano = require("@emurgo/cardano-serialization-lib-nodejs");

				const protocolParams = entityos.get(
				{
					scope: 'onchain-process-transaction',
					context: '_protocolParameters'
				});

				const keys = entityos.get(
				{
					scope: 'onchain-process-transaction',
					context: 'keys'
				});

				//txBuilder = onChainTransaction;

				const _minFeeA = Cardano.BigNum.from_str(protocolParams.linearFee.minFeeA);
				console.log(_minFeeA)

				const _minFeeB = Cardano.BigNum.from_str(protocolParams.linearFee.minFeeB);
				console.log(_minFeeB)

				const linearFee = Cardano.LinearFee.new(
						_minFeeA,
						_minFeeB
					)

				console.log('linearFee');
				console.log(linearFee);

				const onChainTransactionConfig = Cardano.TransactionBuilderConfigBuilder.new()
						.fee_algo(linearFee)
						.max_value_size(protocolParams.maxValSize)
						.max_tx_size(protocolParams.maxTxSize)
						.coins_per_utxo_byte(Cardano.BigNum.from_str(protocolParams.coinsPerUtxoByte))
						.pool_deposit(Cardano.BigNum.from_str(protocolParams.poolDeposit))
    					.key_deposit(Cardano.BigNum.from_str(protocolParams.keyDeposit))
						.prefer_pure_change(true)
						.build();

				console.log('onChainTransactionConfig');
				console.log(onChainTransactionConfig);

				const onChainTransaction = Cardano.TransactionBuilder.new(onChainTransactionConfig);

				console.log('onChainTransaction');
				console.log(onChainTransaction);

				// add outputs
				// then .set_inputs(inputs)

				const prvKey = Cardano.PrivateKey.from_bech32(keys._transactionKeyBech32);

				_.each(dataProcessTransaction.inputs, function (input)
				{
					onChainTransaction.add_key_input(
						prvKey.to_public().hash(),
						Cardano.TransactionInput.new(
							Cardano.TransactionHash.from_bytes(Buffer.from(input.txId, 'hex')),
							input.index
						),
						Cardano.Value.new(Cardano.BigNum.from_str(_.toString(input._amount)))
					);
				});

				
				if (false)
				{
					_.each(dataProcessTransaction.outputs, function (output)
					{
						onChainTransaction.add_output(
							Cardano.TransactionOutput.new(
							dataProcessTransaction._receiverAddress,
							Cardano.Value.new(Cardano.BigNum.from_str(output_amount))
						));
					});

					console.log(onChainTransaction);

					/*onChainTransaction.buildTransaction();

					console.log('txsize');
					const txsize = onChainTransaction.calculateTxSize();
					console.log(txsize);

					const BigNumber = require('bignumber.js');

					const tFee = new BigNumber.default(txsize)
						.times(onChainTransaction.protocolParams['min_fee_a'])
						.plus(onChainTransaction.protocolParams['min_fee_b'])
						.integerValue(BigNumber.default.ROUND_CEIL);

					console.log(tFee)

					*/

				//dataProcessTransaction._fee = onChainTransaction.calculateFee();
				//onChainTransaction.setFee(dataProcessTransaction._fee);
				
					onChainTransaction.paymentTransaction(
					{
						inputs: dataProcessTransaction.inputs,
						outputs: dataProcessTransaction.outputs,
						changeAddress: dataProcessTransaction._senderAddress,
						ttl: dataProcessTransaction.ttl
					});
				

					const fee = onChainTransaction.getFee().toNumber();
					console.log(fee);

					onChainTransaction.prepareTransaction({inputs: dataProcessTransaction.inputs, changeAddress: dataProcessTransaction._senderAddress})

					const witnesses = onChainTransaction.getRequiredWitnesses();
					console.log('witnesses');
					console.log(witnesses);

					console.log('senderaddresshash');
					console.log(dataProcessTransaction._senderAddressHash)

					console.log('keys')
					console.log(dataProcessTransaction.keys)

					const settings = entityos.get({scope: '_settings'});
					let keysEntropy = _.get(settings, 'onchain.cardano.octo.entropy');

					//const _Bip32PrivateKey = new bip32ed25519.Bip32PrivateKey();
					//console.log(_Bip32PrivateKey)

					bip32ed25519.Bip32PrivateKey.fromEntropy(Buffer.from(keysEntropy, 'hex')).then(function (rootKey)
					{
						console.log(rootKey);

						// hardened derivation
						const accountKey = rootKey
							.derive(2147483648 + 1852) // purpose
							.derive(2147483648 + 1815) // coin type
							.derive(2147483648 + 0); // account index

						const spendingKey = accountKey
							.derive(0) // chain
							.derive(0) // payment key index
							.toPrivateKey();

						const pubKey = spendingKey
							.toPublicKey()
							.toBytes();

						console.log('pubKey');
						console.log(pubKey)

						const txHash = onChainTransaction.getTransactionHash();
						console.log('txHash');
						console.log(txHash);

						const witnesses = onChainTransaction.getRequiredWitnesses();
				
						for (const [, bipPath] of witnesses)
						{
							//const privateKey = accountKey.derive(bipPath.chain).derive(bipPath.index).toPrivateKey();
							const privateKey = rootKey.toPrivateKey();
							const witness =
							{
								publicKey: spendingKey.toPublicKey().toBytes(),
								signature: spendingKey.sign(txHash),
							};

							onChainTransaction.addWitness(witness);
						}

						const builtOnChainTransaction = onChainTransaction.buildTransaction();
						console.log('builtOnChainTransaction');
						console.log(builtOnChainTransaction);

						console.log('onChainTransaction');
						console.log(onChainTransaction);

						console.log('onChainTransaction.getOutputAmount');
						console.log(onChainTransaction.getOutputAmount());

						console.log('onChainTransaction.getInputAmount');
						console.log(onChainTransaction.getInputAmount());

						const settings = entityos.get({scope: '_settings'});
						const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');
						const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
						const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});

						const txBuffer = Buffer.from(builtOnChainTransaction.payload, 'hex');

						if (true)
						{
							blockfrostAPI.txSubmit(txBuffer).then(function (data)
							{
								console.log(data)
								
							})
							.catch(function (error)
							{
								console.log(error)
								entityos.invoke('util-end', {error: error.message})
							});
						}
					})
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-sign-typhonjs',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				const { Transaction } = require('@stricahq/typhonjs');

				console.log(Era)

				dataProcessTransaction.protocolParameters.minFeeA = dataProcessTransaction.protocolParameters['min_fee_a'];
				dataProcessTransaction.protocolParameters.minFeeB = dataProcessTransaction.protocolParameters['min_fee_b'];

				dataProcessTransaction.protocolParameters.priceMem = dataProcessTransaction.protocolParameters['price_mem']
				dataProcessTransaction.protocolParameters.priceSteps = dataProcessTransaction.protocolParameters['price_step']

				var onChainTransaction = new Transaction({ protocolParams: dataProcessTransaction.protocolParameters });
				//console.log(onChainTransaction);
				
				if (true)
				{
					_.each(dataProcessTransaction.inputs, function (input)
					{
						onChainTransaction.addInput(input)
					});

					console.log(onChainTransaction.getInputs())
					
					_.each(dataProcessTransaction.outputs, function (output)
					{
						onChainTransaction.addOutput(output)
					});

					console.log(onChainTransaction.getOutputs());

					onChainTransaction.buildTransaction();

					console.log('txsize');
					const txsize = onChainTransaction.calculateTxSize();
					console.log(txsize);

					const BigNumber = require('bignumber.js');

					/*const tFee = new BigNumber.default(txsize)
						.times(onChainTransaction.protocolParams['min_fee_a'])
						.plus(onChainTransaction.protocolParams['min_fee_b'])
						.integerValue(BigNumber.default.ROUND_CEIL);

					console.log(tFee)

					*/

				}

				dataProcessTransaction._fee = onChainTransaction.calculateFee();
				onChainTransaction.setFee(dataProcessTransaction._fee);
				
				if (false)
				{
					onChainTransaction.paymentTransaction(
					{
						inputs: dataProcessTransaction.inputs,
						outputs: dataProcessTransaction.outputs,
						changeAddress: dataProcessTransaction._senderAddress,
						ttl: dataProcessTransaction.ttl
					});
				}

				const fee = onChainTransaction.getFee().toNumber();
				console.log(fee);

				onChainTransaction.prepareTransaction({inputs: dataProcessTransaction.inputs, changeAddress: dataProcessTransaction._senderAddress})

				const witnesses = onChainTransaction.getRequiredWitnesses();
				console.log('witnesses');
				console.log(witnesses);

				console.log('senderaddresshash');
				console.log(dataProcessTransaction._senderAddressHash)

				console.log('keys')
				console.log(dataProcessTransaction.keys)

				const bip32ed25519 = require('@stricahq/bip32ed25519');
				//console.log(bip32ed25519.Bip32PrivateKey);

				const settings = entityos.get({scope: '_settings'});
				let keysEntropy = _.get(settings, 'onchain.cardano.octo.entropy');

				//const _Bip32PrivateKey = new bip32ed25519.Bip32PrivateKey();
				//console.log(_Bip32PrivateKey)

				bip32ed25519.Bip32PrivateKey.fromEntropy(Buffer.from(keysEntropy, 'hex')).then(function (rootKey)
				{
					console.log(rootKey);

					// hardened derivation
					const accountKey = rootKey
						.derive(2147483648 + 1852) // purpose
						.derive(2147483648 + 1815) // coin type
						.derive(2147483648 + 0); // account index

					const spendingKey = accountKey
						.derive(0) // chain
						.derive(0) // payment key index
						.toPrivateKey();

					const pubKey = spendingKey
						.toPublicKey()
						.toBytes();

					console.log('pubKey');
					console.log(pubKey)

					const txHash = onChainTransaction.getTransactionHash();
					console.log('txHash');
					console.log(txHash);

					const witnesses = onChainTransaction.getRequiredWitnesses();
			
					for (const [, bipPath] of witnesses)
					{
						//const privateKey = accountKey.derive(bipPath.chain).derive(bipPath.index).toPrivateKey();
						const privateKey = rootKey.toPrivateKey();
						const witness =
						{
							publicKey: spendingKey.toPublicKey().toBytes(),
							signature: spendingKey.sign(txHash),
						};

						onChainTransaction.addWitness(witness);
					}

					const builtOnChainTransaction = onChainTransaction.buildTransaction();
					console.log('builtOnChainTransaction');
					console.log(builtOnChainTransaction);

					console.log('onChainTransaction');
					console.log(onChainTransaction);

					console.log('onChainTransaction.getOutputAmount');
					console.log(onChainTransaction.getOutputAmount());

					console.log('onChainTransaction.getInputAmount');
					console.log(onChainTransaction.getInputAmount());

					const settings = entityos.get({scope: '_settings'});
					const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');
					const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
					const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});

					const txBuffer = Buffer.from(builtOnChainTransaction.payload, 'hex');

					if (true)
					{
						blockfrostAPI.txSubmit(txBuffer).then(function (data)
						{
							console.log(data)
							
						})
						.catch(function (error)
						{
							console.log(error)
							entityos.invoke('util-end', {error: error.message})
						});
					}
				})
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-submit',
			code: function (data)
			{

				

			}
		})
	}
}
/*
	Create metadata and transaction data 
    Based on JSON data - ie from entityos/entityos

	Supporting process:

	- Create/Mint Actions that have billingstatus = 1 (Billable) and set to billingstatus = 5 (Billed)
		"bill" as in "onchain asset" - latin "sealed document"

	Methods:

	onchain-process-transaction-prepare-get-keys | onchain-process-get-keys
	onchain-process-transaction-prepare-get-keys-account | onchain-process-get-keys-account
	onchain-process-transaction
	onchain-process-transaction-mint

	onchain-process-account-transaction // TODO
		// Octo send asset to the account and then get back the collateral using account keys
		// eg send an SDI/SSI asset
		// Costs cardano transaction fee in both directions.
		// Uses: onchain-process-transaction or onchain-process-transaction-mint

	onchain-process-oncloud-actions
	onchain-process-oncloud-ssi-verifiable-credentials
	onchain-process-oncloud-ssi-verifiable-credentials

	onchain-process-generate-script-address
	onchain-process-transaction-script

	onchain-process-generate-script-plutus-address

	onchain-process-transaction-witness-sign
*/

var entityos = require('entityos');
var _ = require('lodash');
var entityosProtect = require('entityos/entityos.protect.js');

module.exports =
{
	VERSION: '0.0.1',

	init: function (param)
	{
       
//-- GET KEYS

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-get-keys',
			note: 'Get Default (Octo) Keys',
			code: function (data)
			{
				const event = entityos.get({scope: '_event'});

				if (event.accountkey != undefined)
				{
					//Sending from a user account - not Octo
					entityos.invoke('onchain-process-transaction-prepare-get-keys-account');
				}
				else
				{
					//-- DEFAULT OCTO ACCOUNT

					const settings = entityos.get({scope: '_settings'});
					
					event.keysEntropy = _.get(settings, 'onchain.cardano.octo.entropy');

					if (event.keysEntropy == undefined || event.useMnemonic)
					{
						event.mnemonic = _.get(settings, 'onchain.cardano.octo.mnemonic');
					}

					entityos.invoke('onchain-process-transaction-prepare-get-keys-process');
				}	
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-get-keys-account',
			note: 'Get the user onchain account keys based on their event.useraccountkey (core_protect_key.guid)',
			code: function (param, response)
			{
				//!!! NEED VERIFICATION FROM USER
				// -- they need to pass the "accountkey" that was passed back to them via the api when creating the account.

				// The core_protect_key was created as account by octo and can only be seen by Octo (createduser)

				let event = entityos.get({scope: '_event'});

				if (response == undefined)
				{
					if (_.isEmpty(event.accountkey))
					{
						entityos.invoke('util-end', {error: 'Missing accountkey'}, '400');
					}
					else
					{
						entityos.cloud.search(
						{
							object: 'core_protect_key',
							fields: [{name: 'key'}],
							filters:
							[
								{
									field: 'object',
									comparison: 'EQUAL_TO',
									value: 22
								},
								{
									field: 'guid',
									comparison: 'EQUAL_TO',
									value: event.accountkey
								},
								{
									field: 'category',
									comparison: 'EQUAL_TO',
									value: 4
								},
								{
									field: 'type',
									comparison: 'EQUAL_TO',
									value: 2
								},
								{
									field: 'private',
									comparison: 'EQUAL_TO',
									value: 'Y'
								},
								{
									field: 'title',
									comparison: 'EQUAL_TO',
									value: '[onchain-cardano-account-fully-managed]'
								}
							],
							callback: 'onchain-process-transaction-prepare-get-keys-account'
						});
					}
				}
				else
				{
					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', {error: 'No managed on-chain account. You need to generate an account using generate-account.'}, '401');
					}
					else
					{
						let event = entityos.get({scope: '_event'});
						event._account = _.first(response.data.rows);

						const settings = entityos.get({scope: '_settings'});

						const key = _.get(settings, 'protect.key');
						const iv = _.get(settings, 'protect.iv');

						// Key IV Stored Against this Octo API User.
						const decrypted = entityosProtect.decrypt(
						{
							text: event._account.key,
							key: key,
							iv: iv
						});

						const keyInfo = decrypted.textDecrypted;
						const _keyInfo = _.split(keyInfo); //mnemonic|passphrase
						const mnemonic = _.first(_keyInfo);

						const bip39 = require('bip39');
						const entropy = bip39.mnemonicToEntropy(mnemonic);

						event.keysEntropy = entropy;

						entityos.invoke('onchain-process-transaction-prepare-get-keys-process');
					}
				}
			}
		});
	
		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-get-keys-process',
			code: function (data)
			{
				const event = entityos.get({scope: '_event'});

				if (event.keysEntropy == undefined)
				{
					entityos.invoke('util-end',
					{
						error: 'No key entropy set.'
					});
				}
				else
				{
					let onCompleteController = 'onchain-process-transaction-process';

					if (event.controller == 'onchain-process-get-keys' || event.controller == 'onchain-process-transaction-prepare-get-keys')
					{
						onCompleteController = undefined;
					} 

					if (event.controller == 'onchain-process-transaction-mint' 
							|| event.controller == 'onchain-process-oncloud-ssi-verifiable-credentials'
					)
					{
						onCompleteController = 'onchain-process-transaction-mint-process';
					}

					if (event.controller == 'onchain-process-transaction-script')
					{
						onCompleteController = 'onchain-process-transaction-with-script';
					}

					if (event.controller == 'onchain-process-transaction-witness-sign')
					{
						onCompleteController = 'onchain-process-transaction-witness-sign-process';
					}

					function harden(num)
					{
						return 0x80000000 + num;
					}	

					const Cardano = require("@emurgo/cardano-serialization-lib-nodejs");

					let keys =
					{
						root: {},
						account: {},
						transaction: {},
						stake: {}
					};

					// ROOT

					keys.root.private = Cardano.Bip32PrivateKey.from_bip39_entropy(
						Buffer.from(event.keysEntropy, 'hex'),
						Buffer.from(''),
					);

					keys.root.privateBech32 = keys.root.private.to_bech32();
					keys.root.privateRaw = keys.root.private.to_raw_key();
					keys.root.privateEd25519 = keys.root.privateRaw.to_bech32('ed25519_sk');

					// ACCOUNT

					keys.account.path = '/root/derive(harden(1852)/derive(harden(1815))/derive(harden(0))';
					keys.account.private = keys.root.private
						.derive(harden(1852)) // purpose
						.derive(harden(1815)) // coin type
						.derive(harden(0)); // account #0

					keys.account.privateBech32 = keys.account.private.to_bech32();
					keys.account.privateRaw = keys.account.private.to_raw_key();
					keys.account.privateEd25519 = keys.account.privateRaw.to_bech32('ed25519_sk');

					keys.account.public = keys.account.private.to_public();
					keys.account.publicKeyHash = keys.account.public.to_raw_key().hash();
					keys.account._publicKeyHashHex = keys.account.publicKeyHash.to_hex();
					keys.account.publicKeyHashHex = '61' + keys.account.publicKeyHash.to_hex();

					keys.account.publicCredential = Cardano.Credential.from_keyhash(keys.account.publicKeyHash);

					// TRANSACTION

					keys.transaction.path = '/account/derive(0)/derive(0)';
					keys.transaction.private = keys.account.private
						.derive(0) // external
						.derive(0);

					keys.transaction.privateBech32 = keys.transaction.private.to_bech32();
					keys.transaction.privateRaw = keys.transaction.private.to_raw_key();
					keys.transaction.privateEd25519 = keys.transaction.privateRaw.to_bech32('ed25519_sk');
					keys.transaction.public = keys.transaction.private.to_public();
					keys.transaction.publicKeyHash = keys.transaction.public.to_raw_key().hash();
					keys.transaction._publicKeyHashHex = keys.transaction.publicKeyHash.to_hex();
					keys.transaction.publicKeyHashHex = '61' + keys.transaction.publicKeyHash.to_hex();

					keys.transaction.publicCredential = Cardano.Credential.from_keyhash(keys.transaction.publicKeyHash);
				
					keys.transaction._address = Cardano.EnterpriseAddress.new(
						Cardano.NetworkInfo.mainnet().network_id(),
						keys.transaction.publicCredential
					);

					keys.transaction.address = keys.transaction._address.to_address();
					keys.transaction.addressBech32 = keys.transaction.address.to_bech32();
					keys.transaction.addressHex = keys.transaction.address.to_hex();

					// STAKE 

					keys.stake.path = '/account/derive(2)/derive(0)';
					keys.stake.private = keys.account.private
						.derive(2) // chimeric
						.derive(0);

					keys.stake.privateBech32 = keys.stake.private.to_bech32();

					keys.stake.privateRaw = keys.stake.private.to_raw_key();
					keys.stake.privateEd25519 = keys.stake.privateRaw.to_bech32('ed25519_sk');

					keys.stake.public = keys.stake.private.to_public();
					keys.stake.publicKeyHash = keys.stake.public.to_raw_key().hash();
					keys.stake_publicKeyHashHex = keys.stake.publicKeyHash.to_hex();
					keys.stake.publicKeyHashHex = 'e1' + keys.stake.publicKeyHash.to_hex();

					keys.stake.publicCredential = Cardano.Credential.from_keyhash(keys.stake.publicKeyHash);
					
					keys.stake._publicAddress = Cardano.RewardAddress.new(
						Cardano.NetworkInfo.mainnet().network_id(),
						keys.stake.publicCredential
					);

					keys.stake.publicAddress = keys.stake._publicAddress.to_address();
					keys.stake.publicAddressBech32 = keys.stake.publicAddress.to_bech32();

					// ACCOUNT ADDRESSES

					keys.transaction._publicAddress = Cardano.BaseAddress.new(
						Cardano.NetworkInfo.mainnet().network_id(),
						keys.transaction.publicCredential,
						keys.stake.publicCredential
					);

					console.log(JSON.stringify(keys.transaction._publicAddress));

					keys.transaction.publicAddress = keys.transaction._publicAddress.to_address();
					keys.transaction.publicAddressBech32 = keys.transaction.publicAddress.to_bech32();
					keys.transaction.publicAddressHex = keys.transaction.publicAddress.to_hex();

					keys.account._publicAddress = Cardano.EnterpriseAddress.new(
						Cardano.NetworkInfo.mainnet().network_id(),
						keys.account.publicCredential
					);

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'keys',
						value: keys
					});

					let accountName = event.accountkey;
					if (accountName == undefined)
					{
						accountName = 'default[octo]'
					}

					if (onCompleteController == undefined)
					{
						entityos.invoke('util-end', {data:
						{
							publicKeyHex: keys.transaction.publicAddressHex,
							publicAddress: keys.transaction.publicAddressBech32,
							accountkey: accountName
						}});
					}
					else
					{
						entityos.invoke(onCompleteController);
					}
				}
			}
		});

//-- PROCESS TRANSACTION - USING LUCID

		entityos.add(
		{
			name: 'onchain-process-transaction',
			code: function (param, response)
			{
				entityos.set({scope: 'onchain-process-transaction', value: {}});

				// Gets the keys, stores at .data['onchain-process-transaction'].keys
				// 		and then calls: onchain-process-transaction-process on completion.
				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-process',
			code: function ()
			{
				const settings = entityos.get({scope: '_settings'});
				const event = entityos.get({scope: '_event'});

				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});
				
				let maestroAPIKey = _.get(settings, 'onchain.cardano.maestro.apiKey');
				 	// https://docs.gomaestro.org/docs/Getting-started/Sign-up-login.

				dataProcessTransaction.sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (dataProcessTransaction.sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					dataProcessTransaction.sendAmountLovelace = (sendAmountADA * 1000000);
				}

				dataProcessTransaction.recieverAddress = _.get(event, 'recieveraddress');

				if (dataProcessTransaction.recieverAddress == undefined)
				{
					entityos.invoke('util-end', {error: 'No Reciever Address (recieverAddress:) set.'})
				}
				else
				{
					import('lucid-cardano').then(function({ Lucid, Maestro })
					{
						const cardanoNetwork = _.get(event, 'network', 'mainnet'); //preprod, testnet
						const turboSubmit = _.get(event, 'turbosubmit', false);
							// Read about paid turbo transaction submission feature at https://docs.gomaestro.org/docs/Dapp%20Platform/Turbo%20Transaction.

						const submitTransaction = _.get(event, 'submit', true);

						const provider = new Maestro(
						{
							network: cardanoNetwork,
							apiKey: maestroAPIKey, 
							turboSubmit: turboSubmit
						});

						dataProcessTransaction.network =  _.upperFirst(_.toLower(cardanoNetwork));

						Lucid.new(provider, dataProcessTransaction.network)
						.then(function (lucid)
						{
							if (event.mnemonic != undefined && event.useMnemonic)
							{
								lucid.selectWalletFromSeed(event.mnemonic)
							}
							else
							{
								lucid.selectWalletFromPrivateKey(dataProcessTransaction.keys.transaction.privateEd25519);
							}

							lucid.wallet.address()
							.then(function (address)
							{	
								lucid.newTx()
								.payToAddress(dataProcessTransaction.recieverAddress,
									{
										lovelace: BigInt(dataProcessTransaction.sendAmountLovelace)
									})
								.complete()
								.then(function (tx)
								{
									return tx.sign().complete();
								})
								.then(function (signedTx)
								{
									if (submitTransaction)
									{
										return signedTx.submit();
									}
									else
									{
										dataProcessTransaction.processing = {message: 'Signed Transaction', data: {txSigned: signedTx.toString()}};
										entityos.invoke('onchain-process-transaction-finalise', param);
									}
								})
								.then(function(txHash)
								{
									dataProcessTransaction.processing = {message: 'Transaction Submitted', data: {txHash: txHash}};
									entityos.invoke('onchain-process-transaction-finalise', param);
								})
								.catch(function(error)
								{
									dataProcessTransaction.processing = {error: 'Error during transaction process', data: {error: error}};
									entityos.invoke('onchain-process-transaction-finalise', param);
								});
							})	
							.catch(function (error)
							{
								dataProcessTransaction.processing = {error: 'Error during transaction process', data: {error: error}};
								entityos.invoke('onchain-process-transaction-finalise', param);
							});
						})
						.catch(function (error)
						{
							entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
					});
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-finalise',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				if (_.get(event, 'oncomplete') != undefined)
				{
					entityos._util.onComplete({onComplete: _.get(event, 'oncomplete')});
				}
				else
				{
					entityos.invoke('util-end', dataProcessTransaction.processing);
				}
			}
		});

		//-- ONCHAIN-PROCESS-TRANSACTION-MINT // MINT TRANSACTION - CREATE POLICY & ID
		
		entityos.add(
		{
			name: 'onchain-process-transaction-mint',
			code: function ()
			{
				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-mint-process',
			code: function ()
			{
				import('lucid-cardano').then(function({ Lucid, Maestro })
				{
					const settings = entityos.get({scope: '_settings'});
					const event = entityos.get({scope: '_event'});

					const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});
					
					let maestroAPIKey = _.get(settings, 'onchain.cardano.maestro.apiKey');
				 		// https://docs.gomaestro.org/docs/Getting-started/Sign-up-login.

					const cardanoNetwork = _.get(event, 'network', 'mainnet'); //preprod, testnet
					const turboSubmit = _.get(event, 'turbosubmit', false);
						// Read about paid turbo transaction submission feature at https://docs.gomaestro.org/docs/Dapp%20Platform/Turbo%20Transaction.

					const provider = new Maestro(
					{
						network: cardanoNetwork,
						apiKey: maestroAPIKey, 
						turboSubmit: turboSubmit
					});

					dataProcessTransaction.network =  _.upperFirst(_.toLower(cardanoNetwork));

					Lucid.new(provider, dataProcessTransaction.network)
					.then(function(lucid)
					{
						if (event.mnemonic != undefined && event.useMnemonic)
						{
							lucid.selectWalletFromSeed(event.mnemonic)
						}
						else
						{
							lucid.selectWalletFromPrivateKey(dataProcessTransaction.keys.transaction.privateEd25519);
						}

						console.log(lucid)

						lucid.wallet.address()
						.then(function (address)
						{
							const addressDetails = lucid.utils.getAddressDetails(address);
	
							let policy = event.policy;

							if (policy == undefined)
							{
								policy = _.get(settings, 'onchain.cardano.octo.policy')
							}

							if (policy == undefined)
							{
								entityos.invoke('util-end', {error: 'No policy definition set [event.policy|settings.onchain.cardano.octo.policy]'})
							}
							else
							{
								/*
									eg:
										const mintingPolicy = lucid.utils.nativeScriptFromJson(
										{
											type: "all",
											scripts: [
											{ type: "sig", keyHash: addressDetails.paymentCredential.hash },
											{
												type: "before",
												slot: lucid.utils.unixTimeToSlot(Date.now() + 1000000),
											}
											]
										});
								*/

								_.each(policy.scripts, function (script)
								{
									if (_.get(script, 'keyHash') == '{{octopubkeyhash}}' 
										|| _.get(script, 'keyHash') == '{{accountpubkeyhash}}')
									{
										_.set(script, 'keyHash', addressDetails.paymentCredential.hash)
									}
								});

								let mint = {}; 

								mint.policy = lucid.utils.nativeScriptFromJson(policy);
								mint.policyId = lucid.utils.mintingPolicyToId(mint.policy);
							
								mint.assetName = _.get(event, 'assetName');

								if (mint.assetName == undefined)
								{
									mint.assetName = _.get(settings, 'onchain.cardano.octo.assetName')
								}

								mint.assetNameHex = Buffer.from(assetName, 'utf8').toString('hex');
								
								mint.onChainAssetName = mint.policyId + mint.assetNameHex;
	
								mint.quantity = BigInt(_.get(event, 'quantity', 1));

								mint.metadataLabel = _.get(event, 'metadatalabel') // SDA - 18300
	
								if (mint.metadataLabel == undefined)
								{
									function textToNumberBase26(text) {
										let num = 0;
										for (let i = 0; i < text.length; i++) {
											let charCode = text.charCodeAt(i) - 97; // 'a' = 0, 'b' = 1, ..., 'z' = 25
											if (charCode < 0 || charCode > 25) {
												throw new Error("Invalid character: Only lowercase 'a' to 'z' are allowed.");
											}
											num = num * 26 + charCode;
										}
										return num;
									}
								
									mint.metadataLabelName = _.get(event, 'metadatalabelname') // eg SDA

									if (mint.metadataLabelName != undefined)
									{
										mint.metadataLabel = textToNumberBase26(mint.metadataLabelName)
									}
								}

								if (mint.metadataLabel == undefined)
								{
									entityos.invoke('util-end', {error: 'No metadatalabel or metadatalabelname set in the event'});
								}
								else
								{
									function splitStringIntoChunks(inputString, chunkSize = 64) {
										// Split the inputString into chunks of the specified chunkSize (64 by default)
										const chunks = [];
										for (let i = 0; i < inputString.length; i += chunkSize) {
											chunks.push(inputString.slice(i, i + chunkSize));
										}
										return chunks;
									}

									function applyChunkingToJson(jsonObject) {
										return _.cloneDeepWith(jsonObject, (value) => {
											if (_.isString(value) && value.length > 64) {
												return splitStringIntoChunks(value);
											}
											return undefined;
										});
									}

									mint.metadataRaw = event.metadata;

									const ssiMetadata =	entityos.get(
									{
										scope: 'onchain-process-verifiable-credentials',
										context: 'ssi-metadata'
									});

									console.log(ssiMetadata);

									if (ssiMetadata != undefined)
									{
										let ssiMetadataProcessing = _.first(ssiMetadata);
										mint.metadataRaw = ssiMetadataProcessing.data;
										
										entityos.set(
										{
											scope: 'onchain-process-verifiable-credentials',
											context: 'ssi-metadata-processing',
											value: ssiMetadataProcessing
										})
									}

									mint.metadata = 
									{
										[mint.policyId]: mint.metadataRaw
									}

									mint._metadata = applyChunkingToJson(mint.metadata)

									//console.log(JSON.stringify(mint._metadata, null, 2));

									const mintTransaction = _.get(event, 'mint', true);
									
									if (!mintTransaction)
									{
										entityos.invoke('util-end', {message: 'event.mint:false', data: mint});
									}
									else
									{
										mint.validTo = _.get(event, 'validto', 100000);

										lucid.newTx()
										.mintAssets({ [mint.assetName]:mint.quantity })
										.validTo(Date.now() + mint.validTo)
										.attachMintingPolicy( mint.policy)
										.attachMetadata(mint.metadataLabel, mint.quantity_metadata)
										.complete()
										.then(function (tx)
										{	
											return tx.sign().complete();
										})
										.then(function(signedTx)
										{
											const submitTransaction = _.get(event, 'submit', true);

											if (submitTransaction)
											{
												return signedTx.submit();
											}
											else
											{
												dataProcessTransaction.processing = {message: 'Signed Transaction', data: {txSigned: signedTx.toString()}};
												entityos.invoke('onchain-process-transaction-finalise', param);
											}
										})
										.then(function(txHash)
										{
											if (txHash == undefined)
											{
												dataProcessTransaction.processing = {error: 'Error during transaction process', data: {error: error}};
												entityos.invoke('onchain-process-transaction-finalise', param);
											}
											else
											{
												let ssiMetadataProcessing = entityos.get(
												{
													scope: 'onchain-process-verifiable-credentials',
													context: 'ssi-metadata-processing'
												});

												if (ssiMetadataProcessing != undefined)
												{
													ssiMetadataProcessing.txHash = txHash;

													entityos.set(
													{
														scope: 'onchain-process-verifiable-credentials',
														context: 'ssi-metadata-processing',
														value: ssiMetadataProcessing
													});

													entityos.invoke('onchain-process-transaction-mint-save');
												}
												else
												{
													dataProcessTransaction.processing = {message: 'Transaction Submitted', data: {txHash: txHash}};
													entityos.invoke('onchain-process-transaction-finalise', param);
												}
											}
										})
										.catch(function(error)
										{
											dataProcessTransaction.processing = {error: 'Error during transaction process', data: {error: error}};
											entityos.invoke('onchain-process-transaction-finalise', param);
										});
									}
								}
							}
						})
						.catch(function (error)
						{
							entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
					});
				})
				.catch(function (error)
				{
					entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
				});
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-mint-save',
			code: function (param, response)
			{
				let ssiMetadataProcessing = entityos.get(
				{
					scope: 'onchain-process-verifiable-credentials',
					context: 'ssi-metadata-processing',
				});

				if (response == undefined)
				{
					const data =
					{
						id: ssiMetadataProcessing.id,
						notes: '[achievement-ssi-shared-on-chain:' + ssiMetadataProcessing.txHash + ']'
					}

					entityos.cloud.save(
					{
						object: 'core_protect_ciphertext',
						data: data,
						callback: 'onchain-process-transaction-mint-save'
					});
				}
				else
				{
					dataProcessTransaction.processing = {message: 'SSI Processed', data: {txHash: ssiMetadataProcessing.txHash}};
					entityos.invoke('onchain-process-transaction-finalise', param);
				}
			}
		});

		//-- NATIVE SCRIPTS

		entityos.add(
		{
			name: 'onchain-process-generate-script-address',
			code: function ()
			{
				import('lucid-cardano').then(function({ Lucid })
				{
					const event = entityos.get({scope: '_event'});
					const settings = entityos.get({scope: '_settings'});
					
					Lucid.new()
					.then(function(lucid)
					{
						/*
							eg:
								{
									type: "atLeast",
									required: 1,
									scripts: [
										{ type: "sig", keyHash: '4e6c35408d2c85971f38452ae84b40ac6a0c61594d92f851cd0864b7' },
										{ type: "sig", keyHash: '47be87958f74acc8ef7259c58dcd5249e132672d98b113289172a467' }
									]
								}
						*/
						const nativeScript = lucid.utils.nativeScriptFromJson(event.script);
						let scriptAddress = lucid.utils.validatorToAddress(nativeScript);

						let staking = _.get(event, 'staking', false);

						if (staking)
						{
							let stakingHashPublic = _.get(event, 'stakingHashPublic');
							if (stakingHashPublic == undefined)
							{
								stakingHashPublic = _.get(settings, 'onchain.cardano.octo.pubkeyhash')
							}
							
							const stakingCredential = { type: "Key", hash: stakingHashPublic };

							scriptAddress = lucid.utils.validatorToAddress(nativeScript, stakingCredential);
					
							/*
								For later if only script address is known:
								const scriptHash = lucid.utils.getAddressDetails(scriptAddress).paymentCredential.hash;
								const scriptCredential = { type: "Script", hash: scriptHash };
								scriptAddress = lucid.utils.credentialToAddress(scriptCredential, stakingCredential);
							*/
						}

						entityos.invoke('util-end',
						{
							message: 'onchain-process-generate-script-address',
							data: {scriptAddress: scriptAddress}
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
					});
				})
				.catch(function (error)
				{
					entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
				});
			}
		});

		entityos.add(
		{
			name: 'onchain-process-get-script-address-utxos',
			code: function ()
			{
				import('lucid-cardano').then(function({ Lucid, Maestro })
				{
					const settings = entityos.get({scope: '_settings'});
					const event = entityos.get({scope: '_event'});

					const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction', valueDefault: {}});
					
					let maestroAPIKey = _.get(settings, 'onchain.cardano.maestro.apiKey');
				 		// https://docs.gomaestro.org/docs/Getting-started/Sign-up-login.

					const cardanoNetwork = _.get(event, 'network', 'mainnet'); //preprod, testnet
					const turboSubmit = _.get(event, 'turbosubmit', false);
						// Read about paid turbo transaction submission feature at https://docs.gomaestro.org/docs/Dapp%20Platform/Turbo%20Transaction.

					const provider = new Maestro(
					{
						network: cardanoNetwork,
						apiKey: maestroAPIKey, 
						turboSubmit: turboSubmit
					});

					dataProcessTransaction.network =  _.upperFirst(_.toLower(cardanoNetwork));

					Lucid.new(provider, dataProcessTransaction.network)
					.then(function(lucid)
					{
						const nativeScript = lucid.utils.nativeScriptFromJson(event.script);
						let scriptAddress = lucid.utils.validatorToAddress(nativeScript);

						lucid.utxosAt(scriptAddress).then(function (scriptUtxos)
						{
							entityos.invoke('util-end',
							{
								message: 'onchain-process-get-script-address-utxos',
								data:
								{
									scriptAddress: scriptAddress,
									utxos: scriptUtxos
								}
							});
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
					});
				})
				.catch(function (error)
				{
					entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
				});
			}
		});

//-- PLUTUS SCRIPTS

		entityos.add(
		{
			name: 'onchain-process-generate-script-plutus-address',
			code: function ()
			{
				import('lucid-cardano').then(function({ Lucid })
				{
					const event = entityos.get({scope: '_event'});
					const settings = entityos.get({scope: '_settings'});
					
					Lucid.new()
					.then(function(lucid)
					{
						let scriptAddress = lucid.utils.validatorToAddress(event.script);

						let staking = _.get(event, 'staking', false);

						if (staking)
						{
							let stakingHashPublic = _.get(event, 'stakingHashPublic');
							if (stakingHashPublic == undefined)
							{
								stakingHashPublic = _.get(settings, 'onchain.cardano.octo.pubkeyhash')
							}
							
							const stakingCredential = { type: "Key", hash: stakingHashPublic };

							scriptAddress = lucid.utils.validatorToAddress(event.script, stakingCredential);
					
							/*
								For later if only script address is known:
								const scriptHash = lucid.utils.getAddressDetails(scriptAddress).paymentCredential.hash;
								const scriptCredential = { type: "Script", hash: scriptHash };
								scriptAddress = lucid.utils.credentialToAddress(scriptCredential, stakingCredential);
							*/
						}

						let scriptHash = lucid.utils.validatorToScriptHash(event.script);

						entityos.invoke('util-end',
						{
							message: 'onchain-process-generate-script-plutus-address',
							data:
							{
								scriptAddress: scriptAddress,
								scriptHash: scriptHash
							}
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
					});
				})
				.catch(function (error)
				{
					entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
				});
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-witness-sign',
			code: function ()
			{
				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-witness-sign-process',
			code: function ()
			{
				const settings = entityos.get({scope: '_settings'});
				const event = entityos.get({scope: '_event'});

				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction', valueDefault: {}});
				
				let maestroAPIKey = _.get(settings, 'onchain.cardano.maestro.apiKey');

				dataProcessTransaction.sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (dataProcessTransaction.sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					dataProcessTransaction.sendAmountLovelace = (sendAmountADA * 1000000);
				}

				dataProcessTransaction.recieverAddress = _.get(event, 'recieveraddress');

				if (dataProcessTransaction.keys == undefined)
						
				{
					entityos.invoke('util-end', {error: 'No keys to witness sign with.'})
				}
				else
				{
					import('lucid-cardano').then(function({ Lucid, Maestro })
					{
						const cardanoNetwork = _.get(event, 'network', 'mainnet'); //preprod, testnet
						
						/*const provider = new Maestro(
						{
							network: cardanoNetwork,
							apiKey: maestroAPIKey, 
							turboSubmit: turboSubmit
						});*/

						dataProcessTransaction.network =  _.upperFirst(_.toLower(cardanoNetwork));

						Lucid.new(undefined, dataProcessTransaction.network)
						.then(function (lucid)
						{	
							if (event.mnemonic != undefined && event.useMnemonic)
							{
								lucid.selectWalletFromSeed(event.mnemonic)
							}
							else
							{
								lucid.selectWalletFromPrivateKey(dataProcessTransaction.keys.transaction.privateEd25519);
							}

							lucid.wallet.address()
							.then(function (address)
							{	
								const pubKeyHash = lucid.utils.getAddressDetails(address).paymentCredential?.hash;

								// Deserialize the transaction
								const tx = lucid.fromTx(_.get(event, 'transaction.cborHex'));
								
								// Sign the transaction
								tx.partialSign()
								.then(function (signedTxHex)
								{
									dataProcessTransaction.signedTransactionData =
									{
										description: "Witness Signed transaction",
										cborHex: signedTxHex,
										signedAt: new Date().toISOString(),
										pubKeyHash: pubKeyHash,
										transaction: _.get(event, 'transaction')
									}
								
									dataProcessTransaction.processing =
									{
										message: 'Witness Signed Transaction',
										data: dataProcessTransaction.signedTransactionData
									};

									entityos.invoke('util-end', dataProcessTransaction.processing);
								})
								.catch(function (error)
								{
									dataProcessTransaction.processing = {error: 'Error witness signing', data: {error: error}};
									entityos.invoke('util-end', dataProcessTransaction.processing);
								});
							});
						})
						.catch(function (error)
						{
							entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
					});
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-script',
			code: function ()
			{
				// In future switch if Plutus Script

				entityos.invoke('onchain-process-transaction-prepare-get-keys');
				//entityos.invoke('onchain-process-transaction-with-script');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-with-script',
			code: function ()
			{
				// To Do: make work with plutus Scripts also.

				// If needs witnesses and no witnesses then return unsigned transaction
				//Witness signatures are passed through with the event.

				/*
					eg:
						{
							type: "atLeast",
							required: 1,
							scripts: [
								{ type: "sig", keyHash: '4e6c35408d2c85971f38452ae84b40ac6a0c61594d92f851cd0864b7' },
								{ type: "sig", keyHash: '47be87958f74acc8ef7259c58dcd5249e132672d98b113289172a467' }
							]
						}
				*/

				const settings = entityos.get({scope: '_settings'});
				const event = entityos.get({scope: '_event'});

				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction', valueDefault: {}});
				
				let maestroAPIKey = _.get(settings, 'onchain.cardano.maestro.apiKey');

				dataProcessTransaction.sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (dataProcessTransaction.sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					dataProcessTransaction.sendAmountLovelace = (sendAmountADA * 1000000);
				}

				dataProcessTransaction.recieverAddress = _.get(event, 'recieveraddress');

				if (dataProcessTransaction.recieverAddress == undefined
						|| event.script == undefined)
				{
					entityos.invoke('util-end', {error: 'No Reciever Address (recieverAddress:) or Script (script:) set.'})
				}
				else
				{
					import('lucid-cardano').then(function({ Lucid, Maestro, Data, Constr })
					{
						const cardanoNetwork = _.get(event, 'network', 'mainnet'); //preprod, testnet
						const turboSubmit = _.get(event, 'turbosubmit', false);
				
						const provider = new Maestro(
						{
							network: cardanoNetwork,
							apiKey: maestroAPIKey, 
							turboSubmit: turboSubmit
						});

						dataProcessTransaction.network =  _.upperFirst(_.toLower(cardanoNetwork));

						Lucid.new(provider, dataProcessTransaction.network)
						.then(function (lucid)
						{
							var scriptAddress;
							const isPlutusScript = _.includes(_.toLower(_.get(event, 'script.type', '')), 'plutus');

							if (isPlutusScript)
							{
								scriptAddress = lucid.utils.validatorToAddress(event.script);
							}
							else
							{
								const nativeScript = lucid.utils.nativeScriptFromJson(event.script);
								scriptAddress = lucid.utils.validatorToAddress(nativeScript);
							}

							//https://lucid.spacebudz.io/docs/getting-started/smart-contract/

							lucid.utxosAt(scriptAddress)
							.then(function (scriptUtxos)
							{
								if (scriptUtxos.length == 0)
								{
									entityos.invoke('util-end',
									{
										message: 'No UTxOs at native script address.',
										data:
										{
											scriptAddress: scriptAddress
										}
									});
								}
								else
								{
									if (event.mnemonic != undefined && event.useMnemonic)
									{
										console.log('selectWalletFromSeed')
										lucid.selectWalletFromSeed(event.mnemonic)
									}
									else
									{
										console.log('selectWalletFromPrivateKey')
										lucid.selectWalletFromPrivateKey(dataProcessTransaction.keys.transaction.privateEd25519);
									}

									// Construct spending transaction (unsigned)
									console.log('scriptUtxos');
									console.log(scriptUtxos);

									//lucid.wallet.address()
									//.then(function (address)
									//{		
										let transaction;

										if (_.isPlainObject(_.get(event, 'transaction')))
										{
											console.log(_.get(event, 'transaction'));
											transaction = lucid.fromTx(_.get(event, 'transaction').cborHex);
										}
										else
										{
											transaction = lucid.newTx();
										}

										if (isPlutusScript)
										{
											console.log(event.redeemer);
const redeemer = Data.to(Buffer.from("Hello, World!").toString("hex"));
console.log(redeemer)
											transaction
											.collectFrom(scriptUtxos, redeemer)	
											transaction.attachSpendingValidator(event.script);
										}
										else
										{
											transaction.collectFrom(scriptUtxos)	
											transaction.attachSpendingValidator(nativeScript);
										}

										transaction.payToAddress(dataProcessTransaction.recieverAddress,
										{
											lovelace: BigInt(dataProcessTransaction.sendAmountLovelace)
										});

										if (event.useScript)
										{
											const details = lucid.utils.getAddressDetails(scriptAddress);

											console.log("\nAddress Details:", details);

											if (details.paymentCredential?.type === "Script") {
												console.log("Payment Credential Type: Script");
												console.log("Script Hash:", details.paymentCredential.hash);
												console.log("This hash is derived from the native script, but you CANNOT get the original script or the required PKHs back from this hash alone.");
											} else if (details.paymentCredential?.type === "Key") {
												console.log("Payment Credential Type: Key (This is NOT a script address)");
												console.log("Associated PKH:", details.paymentCredential.hash); // This is the PKH if it's a simple address
											}

											transaction.addSignerKey(details.paymentCredential.hash)
										}

										//console.log(transaction)

										var witnessSet;

										if (_.isArray(_.get(event, 'witnesses')))
										{
											witnessSet = _.map(_.get(event, 'witnesses'),
											function (witness)
											{
												return witness.cborHex
											});
										}

										transaction.complete()
										.then(function (txUnSigned)
										{
											if (witnessSet != undefined)
											{
												txUnSigned.assemble(witnessSet);
											}

											dataProcessTransaction.unsignedTransaction = txUnSigned;
											dataProcessTransaction.unsignedTransactionData = 
											{
												type: "Tx BabbageEra",
												description: "Unsigned transaction from script address",
												cborHex: dataProcessTransaction.unsignedTransaction.toString(),
												network: dataProcessTransaction.network,
												script: event.script,
												createdAt: new Date().toISOString(),
												receiverAddress: dataProcessTransaction.recieverAddress,
												amountLovelace: dataProcessTransaction.sendAmountLovelace
											};

											const submitTransaction = _.get(event, 'submit', false);

											if (!submitTransaction)
											{
												dataProcessTransaction.processing =
												{
													message: 'Unsigned Transaction',
													data: dataProcessTransaction.unsignedTransactionData
												};

												entityos.invoke('onchain-process-transaction-finalise', param);
											}
											else
											{
												txUnSigned.sign().complete()
												.then(function (signedTx)
												{
													return signedTx.submit();
												})
												.then(function(txHash)
												{
													dataProcessTransaction.processing = {message: 'Transaction Submitted', data: {txHash: txHash}};
													entityos.invoke('onchain-process-transaction-finalise', param);
												})
												.catch(function(error)
												{
													dataProcessTransaction.processing = {error: 'Error during transaction process', data: {error: error}};
													entityos.invoke('onchain-process-transaction-finalise', param);
												});

											}
										})
										.catch(function (error)
										{
											dataProcessTransaction.processing = {error: 'Error getting script address UTxOs', data: {error: error}};
											entityos.invoke('onchain-process-transaction-finalise', param);
										});
									//});
								}
							})
							/*.catch(function (error)
							{
								dataProcessTransaction.processing = {error: 'Error getting script address UTxOs', data: {error: error}};
								entityos.invoke('onchain-process-transaction-finalise', param);
							});*/
						})
						.catch(function (error)
						{
							entityos.invoke('util-end', {error: 'Error initializing Lucid', data: {error: error}});
						});
					})
					.catch(function (error)
					{
						entityos.invoke('util-end', {error: 'Error importing Lucid', data: {error: error}});
					});
				}
				/*

					import { Lucid, Maestro } from "lucid-cardano";
					import { writeFileSync } from "fs";

					async function main() {
					const MAESTRO_API_KEY = "your_maestro_api_key";
					const NETWORK = "Mainnet"; // Change to "Preprod" or "Preview" for testnet

					const lucid = await Lucid.new(
						new Maestro(NETWORK, MAESTRO_API_KEY),
						NETWORK
					);

					// Define Multi-Sig Script
					const signer1Hash = "first_signer_payment_hash"; // Replace with actual hash
					const signer2Hash = "second_signer_payment_hash"; // Replace with actual hash

					const multiSigScript = {
						type: "all", // Requires both signatures to approve
						scripts: [
							{ type: "sig", keyHash: signer1Hash },
							{ type: "sig", keyHash: signer2Hash },
						]
					};

					const scriptAddress = lucid.utils.scriptAddress(multiSigScript);
					console.log("Multi-Sig Script Address:", scriptAddress);

					// Get UTXOs from the script address
					const utxos = await lucid.utxosAt(scriptAddress);
					if (utxos.length === 0) {
						throw new Error("No UTXOs available at script address.");
					}

					// Construct spending transaction (unsigned)
					const tx = await lucid.newTx()
						.collectFrom(utxos, multiSigScript) // Spend from script
						.payToAddress("addr1...recipient...", { lovelace: BigInt(5_000_000) }) // Send funds to recipient
						.complete();

					// Export unsigned transaction
					const unsignedTx = tx.toString();
					writeFileSync("unsignedTx.json", JSON.stringify({ unsignedTx }));

					console.log("Unsigned transaction saved. Send `unsignedTx.json` to signers.");
					}

					main().catch(console.error);

				*/


				/*

				import { Lucid, Maestro } from "lucid-cardano";
				import { readFileSync, writeFileSync } from "fs";

				async function main() {
					const MAESTRO_API_KEY = "your_maestro_api_key";
					const NETWORK = "Mainnet";

					const lucid = await Lucid.new(
						new Maestro(NETWORK, MAESTRO_API_KEY),
						NETWORK
					);

					// Load signer's private key
					const signerKey = readFileSync("signer.skey", "utf8"); // Replace with actual signer file
					lucid.selectWalletFromPrivateKey(signerKey);

					// Load unsigned transaction
					const unsignedTx = JSON.parse(readFileSync("unsignedTx.json", "utf8")).unsignedTx;

					// Generate witness signature
					const tx = await lucid.fromTx(unsignedTx);
					const witness = await tx.sign().complete();

					// Save witness file
					const witnessData = witness.toString();
					writeFileSync(`witness_${await lucid.wallet.address()}.json`, JSON.stringify({ witness: witnessData }));

					console.log("Witness saved. Send back to orchestrator.");
				}

				main().catch(console.error);

				*/

				/*
					import { Lucid, Maestro } from "lucid-cardano";
					import { readFileSync } from "fs";

					async function main() {
						const MAESTRO_API_KEY = "your_maestro_api_key";
						const NETWORK = "Mainnet";

						const lucid = await Lucid.new(
							new Maestro(NETWORK, MAESTRO_API_KEY),
							NETWORK
						);

						// Load unsigned transaction
						const unsignedTx = JSON.parse(readFileSync("unsignedTx.json", "utf8")).unsignedTx;

						// Load witnesses from signers
						const witness1 = JSON.parse(readFileSync("witness_signer1.json", "utf8")).witness;
						const witness2 = JSON.parse(readFileSync("witness_signer2.json", "utf8")).witness;

						// Merge witnesses
						const finalTx = await lucid.fromTx(unsignedTx)
							.attachWitness(witness1)
							.attachWitness(witness2)
							.complete();

						// Submit transaction
						const txHash = await finalTx.submit();
						console.log("Transaction submitted! Hash:", txHash);
					}

					main().catch(console.error);
				*/

				//const { Lucid, Maestro } = require('./lucid-cardano/esm/mod.js');
			}
		});

//-- ALIASES

		entityos.add(
		{
			name: 'onchain-process-get-keys',
			code: function (param, response)
			{
				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		entityos.add(
		{
			name: 'onchain-process-get-keys-account',
			code: function (param, response)
			{
				entityos.invoke('onchain-process-transaction-prepare-get-keys-account');
			}
		});

//-- PROCESS ENTITYOS ACTIONS

		entityos.add(
		{
			name: 'onchain-process-oncloud-actions',
			notes: 'Get actions that have billingstatus = 1 (Billable) eg creating SSI proofs on-chain',
			code: function (param, response)
			{
				if (response == undefined)
				{
					let actionTypes = _.get(param, 'actionTypes');
			
					if (actionTypes == undefined)
					{
						const event = entityos.get({scope: '_event'});
						actionTypes = _.get(event, 'actionTypes');
					}

					if (_.startsWith(actionTypes, 'setting:'))
					{
						// eg setting:selfdriven.actionTypes.achievements
						const settings = entityos.get({scope: '_settings'});
						const setting = _.replace(actionTypes, 'setting:', '');
						actionTypes = _.get(settings, setting);
					}

					if (actionTypes == undefined)
					{
						_.set(param, 'error', 'No Action Type(s) set.')
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.cloud.search(
						{
							object: 'action',
							fields: [{ name: 'guid' }],
							filters: 
							[
								{
									field: 'type',
									comparison: 'IN_LIST',
									value: actionTypes
								}
							],
							rows: 10,
							callback: 'onchain-process-oncloud-actions'
						});
					}
				}
				else
				{
					entityos.set(
					{
						scope: 'onchain-process-oncloud-actions',
						context: 'actions',
						value: response.data.rows
					});

					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', {message: 'No actions to process.'})
					}
					else
					{
						entityos.invoke('onchain-process-oncloud-ssi-verifiable-credentials', param);
					}
				}  
			}	
		});	

		entityos.add(
		{
			name: 'onchain-process-oncloud-ssi-verifiable-credentials',
			notes: 'Get associated SSI data eg Verifiable Credential',
			code: function (param, response)
			{
				const settings = entityos.get({scope: '_settings'});

				if (response == undefined)
				{
					var actions = entityos.get(
					{
						scope: 'onchain-process-oncloud-actions',
						context: 'actions',
						valueDefault: []
					});

					var filters = [];

					if (actions.length != 0)
					{
						filters.push(
						{
							field: 'objectcontext',
							comparison: 'IN_LIST',
							value: _.join(_.map(actions, 'id'), ',')
						});
					}
					else
					{
						filters.push(
						{
							field: 'notes',
							comparison: 'EQUAL_TO',
							value: '[achievement-ssi-share-on-chain]'
						});
					}

					const octoSigningKeyID = _.get(settings, 'protect.sign.keyID');

					if (octoSigningKeyID != undefined)
					{
						filters.push(
						{
							field: 'key',
							comparison: 'EQUAL_TO',
							value: octoSigningKeyID
						});
					}

					// !!! Rows on 1 for testing

					entityos.cloud.search(
					{
						object: 'core_protect_ciphertext',
						fields: [{ name: 'sourcetext' }, { name: 'objectcontext' }],
						filters: filters,
						rows: 1,
						callback: 'onchain-process-oncloud-ssi-verifiable-credentials'
					});					
				}
				else
				{
					entityos.set(
					{
						scope: 'onchain-process-verifiable-credentials',
						context: 'ssi',
						value: response.data.rows
					});

					let ssiMetadata = [];

					if (response.data.rows.length == 0)
					{
						entityos.invoke('util-end', {message: 'No shared verifiable credentials to be processed.'})
					}
					else
					{
						const cardanoSDAAsset = _.get(settings, 'onchain.cardano.assets.sda')

						_.each(response.data.rows, function (row)
						{
							row._ssiVC = JSON.parse(Buffer.from(row.sourcetext, 'base64').toString('utf-8'));
							console.log(Buffer.from(row.sourcetext, 'base64').toString('utf-8'))

							row._sdaOnChainData = {};

							_.set(row._sdaOnChainData, 'SSI',
							{
								"id": row._ssiVC.id,
								"issuer": row._ssiVC.issuer,
								"proof": row._ssiVC.proof
							});

							const event = entityos.get({scope: '_event'});

							let includeSubjectSkill = _.get(event, 'includeSubjectSkill');

							if (includeSubjectSkill == undefined)
							{
								includeSubjectSkill = _.get(settings, 'onchain.cardano.octo.includeSubjectSkill', false);
							}

							let includeSubjectID = _.get(event, 'includeSubjectID');

							if (includeSubjectID == undefined)
							{
								includeSubjectID = _.get(settings, 'onchain.cardano.octo.includeSubjectID', false);
							}

							if (includeSubjectSkill || includeSubjectID)
							{
								row._sdaOnChainData.SSI.credentialSubject = [];

								_.each(row._ssiVC.credentialSubject, function (_credentialSubject)
								{
									let credentialSubject = {};

									if (includeSubjectSkill)
									{
										credentialSubject = 
										{
											skillId: _credentialSubject.skillId,
											skillName: _credentialSubject.skillName
										}
									}

									if (includeSubjectID)
									{
										const anonSubjectID = _.get(event, 'anonSubjectID', true);

										if (!_.includes(_credentialSubject.id, 'anon'))
										{
											const _id = _.split(_credentialSubject.id, ':');
											const _idAnon = entityos.invoke('onchain-process-generate-hash',
											{
												text: _.last(_id)
											});

											_credentialSubject.id = _id[0] + ':' + _id[1] + ':anon:' + _idAnon.hashedtexthex

										}
										credentialSubject = _.assign(credentialSubject,
										{
											id: _credentialSubject.id
										})
									}

									row._sdaOnChainData.SSI.credentialSubject.push(credentialSubject);
								});
							}

							console.log(JSON.stringify(row._sdaOnChainData, null, 2))

							ssiMetadata.push(
							{
								id: row.id,
								data: row._sdaOnChainData
							});
						});

						entityos.set(
						{
							scope: 'onchain-process-verifiable-credentials',
							context: 'ssi-metadata',
							value: ssiMetadata
						});

						entityos.invoke('onchain-process-transaction-mint');
						// update to use onchain-process-account-transaction-mint
					}
				}  
			}	
		});

//-- UTIL HELPERS -- MOVE TO onchainfactory.util.js

		entityos.add(
		{
			name: 'onchain-process-util-get-protocol-parameters',
			code: function (data)
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				if (dataProcessTransaction.protocolParameters == undefined)
				{
					const settings = entityos.get({scope: '_settings'});
					const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');

					if (blockfrostProjectID == undefined)
					{
						entityos.invoke('util-end',
						{
							error: 'No access to onchain data / indexing service. [indexer-service-api-key-not-set]'
						});
					}
					else
					{
						const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
						const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});
						
						//console.log(blockfrostAPI)

						blockfrostAPI.epochsLatestParameters().then(function (parameters)
						{
							entityos.set(
							{
								scope: 'onchain-process-transaction',
								context: 'protocolParameters',
								value: parameters
							});
							
							//console.log(parameters)
							entityos.invoke('onchain-process-transaction-prepare');
						})
						.catch(function (error)
						{
							console.log(error)
							entityos.invoke('util-end', {error: error.message})
						});
					}
				}
				else
				{
					entityos.invoke('onchain-process-transaction-prepare');
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-util-get-latest-slot',
			code: function (e)
			{
				const settings = entityos.get({scope: '_settings'});
				const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');
				const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
				const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID});

				console.log(blockfrostAPI)

				blockfrostAPI.blocksLatest().then(function (data)
				{
					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'latest-block',
						value: data
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'latest-slot',
						value: data.slot
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'ttl',
						value: data.slot + 7200 // 2 hours
					});
					
					entityos.invoke('onchain-process-transaction-prepare-utxos');
					//entityos.invoke('onchain-process-transaction-prepare-get-keys');
				})
				.catch(function (error)
				{
					console.log(error)
					entityos.invoke('util-end', {error: error.message})
				});
			}
		});

//-- FINE GRAIN PROCESS TRANSACTION

		// Octo or User == Passed key.id for shared custody Cardano wallet/account
		// Get Cardano Protocol Parameters - Lucid does this.
		// Get the Octo or User Keys
		// Prepare transaction
		// Sign transaction
		// Submit transaction
		
		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-utxos',
			notes: 'NOT USED',
			code: function (param, response)
			{
				let utxos = entityos.get(
				{
					scope: 'onchain-process-transaction',
					context: 'utxos'
				});

				const event = entityos.get({scope: '_event'});

				let sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					sendAmountLovelace = (sendAmountADA * 1000000);
				}

				_.each(utxos, function (utxo)
				{
					utxo._lovelaces = _.filter(utxo.amount, function (amount)
					{
						return (amount.unit == 'lovelace')
					});

					utxo.lovelace = _.sum(_.map(utxo._lovelaces, function (lovelace) {return parseInt(lovelace.quantity)}));
					utxo.ada = utxo.lovelace / 1000000;

					utxo.lovelaceOnly = (utxo.amount.length == 1);

					/*
						{
							"address": "addr1q98xcd2q35kgt9cl8pzj46ztgzkx5rrpt9xe97z3e5yxfdlrm5zhvgxwkfc0zwdywruts8waa4nkkh3x24z9taqhhqtsqrucn3",
							"tx_hash": "a130469699670bb6520ae4943fa9abb3a1d0bc0f1d0b627fb9f83ded5b14a018",
							"tx_index": 0,
							"output_index": 0,
							"amount": [
							{
								"unit": "lovelace",
								"quantity": "5000000"
							}
							],
							"block": "f6fda94f979547c6a40d10fb48b033127257e958d828ca8b17b5db42d8d90fd6",
							"data_hash": null,
							"inline_datum": null,
							"reference_script_hash": null
						}
					*/
				});

				console.log(JSON.stringify(utxos, null, 2));

				const totalAmountLoveLace = _.sum(_.map(utxos, function (utxo) {return parseInt(utxo.lovelace)}));

				if (sendAmountLovelace > totalAmountLoveLace)
				{
					entityos.invoke('util-end',
					{
						error: 'Not enough lovelace (ADA) available.'
					});
				}
				else
				{
					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'totalAmountLoveLace',
						value: totalAmountLoveLace
					});

					entityos.set(
					{
						scope: 'onchain-process-transaction',
						context: 'utxos',
						value: utxos
					});

					//entityos.invoke('onchain-process-transaction-prepare-inputs')
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-inputs',
			notes: 'Gets the utxos and selects the smallest ones until gets to total amount required.',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});

				// Use up smaller utxos first as a form of consolidation

				dataProcessTransaction.utxos = _.sortBy(dataProcessTransaction.utxos, 'lovelace');

				const event = entityos.get({scope: '_event'});
				let sendAmountLovelace = _.get(event, 'sendamountlovelace');

				if (sendAmountLovelace == undefined)
				{
					const sendAmountADA = _.get(event, 'sendamountada', 0);
					sendAmountLovelace = (sendAmountADA * 1000000);
				}

				sendAmountLovelace = parseInt(sendAmountLovelace);

				dataProcessTransaction.sendAmountLovelace = sendAmountLovelace;
				
				if (sendAmountLovelace == 0)
				{
					entityos.invoke('util-end',
					{
						error: 'Send amount is 0.'
					});
				}
				else
				{
					let utxosTotalLovelace = 0;
					let sendAmountLovelaceCovered = false;

					const settings = entityos.get({scope: '_settings'});

					let sendAmountLovelaceMinimum = _.get(settings, 'onchain.cardano.inputsminimumlovelace', 0);
					if (sendAmountLovelace > sendAmountLovelaceMinimum)
					{
						sendAmountLovelaceMinimum = sendAmountLovelace;
					}

					console.log('sendAmountLovelaceMinimum:' + sendAmountLovelaceMinimum)

					_.each(dataProcessTransaction.utxos, function (utxo)
					{
						utxosTotalLovelace = utxosTotalLovelace + utxo.lovelace;

						utxo.includeAsInput = false;

						if (!sendAmountLovelaceCovered)
						{
							utxo.includeAsInput = true;
							if (utxosTotalLovelace > sendAmountLovelaceMinimum)
							{
								sendAmountLovelaceCovered = true
							}
						}
					});

					dataProcessTransaction.utxoInputs = _.filter(dataProcessTransaction.utxos, function (utxo)
					{
						return utxo.includeAsInput
					});

					console.log(JSON.stringify(dataProcessTransaction.utxoInputs, null, 2));

					if (!sendAmountLovelaceCovered)
					{
						entityos.invoke('util-end',
						{
							error: 'Not enough available transactions as inputs.'
						});
					}
					else
					{
						// Inputs format based on typhonjs
						// https://github.com/StricaHQ/typhonjs/tree/master/tests

						dataProcessTransaction.inputs = [];

						const BigNumber = require('bignumber.js');

						const utils = require('@stricahq/typhonjs/dist/utils/utils.js');
						
						console.log(utils)

						dataProcessTransaction._senderAddress = utils.getAddressFromString(dataProcessTransaction.senderAddress);
						dataProcessTransaction._recieverAddress = utils.getAddressFromString(dataProcessTransaction.recieverAddress);

						console.log(JSON.stringify(dataProcessTransaction._senderAddress, null, 2))

						dataProcessTransaction._senderAddressHash = _.get(dataProcessTransaction._senderAddress, '_paymentCredential.hash');
						
						_.each(dataProcessTransaction.utxoInputs, function (utxoInput)
						{
							dataProcessTransaction.inputs.push(
							{
								txId: utxoInput.tx_hash,
								index: parseInt(utxoInput.tx_index),
								amount: new BigNumber(utxoInput.lovelace),
								address: dataProcessTransaction._senderAddress,
								tokens: []
							});
						});
					
						entityos.invoke('onchain-process-transaction-prepare-outputs')
					}
				}
			}
		});

		entityos.add(
		{
			name: 'onchain-process-transaction-prepare-outputs',
			code: function ()
			{
				const dataProcessTransaction = entityos.get({scope: 'onchain-process-transaction'});
				const BigNumber = require('bignumber.js');

				// Outputs format based on typhonjs
				// https://github.com/StricaHQ/typhonjs/tree/master/tests

				dataProcessTransaction.outputs =
				[
					{
						address: dataProcessTransaction._recieverAddress,
						amount: new BigNumber(dataProcessTransaction.sendAmountLovelace)
					}
				]

				// This function works out of default octo keys or specified account
				entityos.invoke('onchain-process-transaction-prepare-get-keys');
			}
		});

		//-- DELEGATE TO DREP

		entityos.add(
		{
			name: 'onchain-process-governance-delegate-to-drep',
			code: function ()
			{}
		});

		//-- UTIL - GENERATE HASH

		entityos.add(
		{
			name: 'onchain-process-generate-hash',
			code: function (data)
			{
				if (data == undefined)
				{
					data = {}
				}

				var blake2b = require('blake2b');

				if (_.isPlainObject(data.text))
				{
					data.text = JSON.stringify(data.text)
				}

				if (data.bytes == undefined)
				{
					if (data.hashlength == undefined)
					{
						data.hashlength = 256
						data.bytes = 32
					}
					else
					{
						data.bytes = data.hashlength / 8
					}
				}

				if (data.hashlength == undefined)
				{
					data.hashlength = data.bytes * 8;
				}

				var output = new Uint8Array(data.bytes);
				
				const hash = blake2b(output.length);
				hash.update(Buffer.from(data.text));
				hash.digest(output);

				data.hashedtexthex = Buffer.from(output).toString('hex');

				return data
			}
		});
	}
}


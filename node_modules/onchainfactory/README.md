
# OLD CODE:

if (false)
{
	//const { Transaction } = require('@stricahq/typhonjs');

	//console.log(Era)

	dataProcessTransaction.protocolParameters.minFeeA = dataProcessTransaction.protocolParameters['min_fee_a'];
	dataProcessTransaction.protocolParameters.minFeeB = dataProcessTransaction.protocolParameters['min_fee_b'];

	dataProcessTransaction.protocolParameters.priceMem = dataProcessTransaction.protocolParameters['price_mem']
	dataProcessTransaction.protocolParameters.priceSteps = dataProcessTransaction.protocolParameters['price_step']

	//var onChainTransaction = new Transaction({ protocolParams: dataProcessTransaction.protocolParameters });
	//console.log(onChainTransaction);


	_.each(dataProcessTransaction.inputs, function (input)
	{
		onChainTransaction.addInput(input)
	});

	console.log(onChainTransaction.getInputs())
	
	_.each(dataProcessTransaction.outputs, function (output)
	{
		onChainTransaction.addOutput(output)
	});

	console.log(onChainTransaction.getOutputs());

	onChainTransaction.buildTransaction();

	console.log('txsize');
	const txsize = onChainTransaction.calculateTxSize();
	console.log(txsize);

	const BigNumber = require('bignumber.js');

	/*const tFee = new BigNumber.default(txsize)
		.times(onChainTransaction.protocolParams['min_fee_a'])
		.plus(onChainTransaction.protocolParams['min_fee_b'])
		.integerValue(BigNumber.default.ROUND_CEIL);

	console.log(tFee)

	*/

	dataProcessTransaction._fee = onChainTransaction.calculateFee();
	onChainTransaction.setFee(dataProcessTransaction._fee);

	onChainTransaction.paymentTransaction(
	{
		inputs: dataProcessTransaction.inputs,
		outputs: dataProcessTransaction.outputs,
		changeAddress: dataProcessTransaction._senderAddress,
		ttl: dataProcessTransaction.ttl
	});


	const fee = onChainTransaction.getFee().toNumber();
	console.log(fee);

	onChainTransaction.prepareTransaction({inputs: dataProcessTransaction.inputs, changeAddress: dataProcessTransaction._senderAddress})

	const witnesses = onChainTransaction.getRequiredWitnesses();
	console.log('witnesses');
	console.log(witnesses);

	console.log('senderaddresshash');
	console.log(dataProcessTransaction._senderAddressHash)

	console.log('keys')
	console.log(dataProcessTransaction.keys)

	const bip32ed25519 = require('@stricahq/bip32ed25519');
	//console.log(bip32ed25519.Bip32PrivateKey);

	let keysEntropy = _.get(settings, 'onchain.cardano.octo.entropy');

	//const _Bip32PrivateKey = new bip32ed25519.Bip32PrivateKey();
	//console.log(_Bip32PrivateKey)

	bip32ed25519.Bip32PrivateKey.fromEntropy(Buffer.from(keysEntropy, 'hex')).then(function (rootKey)
	{
		console.log(rootKey);

		// hardened derivation
		const accountKey = rootKey
			.derive(2147483648 + 1852) // purpose
			.derive(2147483648 + 1815) // coin type
			.derive(2147483648 + 0); // account index

		const spendingKey = accountKey
			.derive(0) // chain
			.derive(0) // payment key index
			.toPrivateKey();

		const pubKey = spendingKey
			.toPublicKey()
			.toBytes();

		console.log('pubKey');
		console.log(pubKey)

		const txHash = onChainTransaction.getTransactionHash();
		console.log('txHash');
		console.log(txHash);

		const witnesses = onChainTransaction.getRequiredWitnesses();

		for (const [, bipPath] of witnesses)
		{
			//const privateKey = accountKey.derive(bipPath.chain).derive(bipPath.index).toPrivateKey();
			const privateKey = rootKey.toPrivateKey();
			const witness =
			{
				publicKey: spendingKey.toPublicKey().toBytes(),
				signature: spendingKey.sign(txHash),
			};

			onChainTransaction.addWitness(witness);
		}

		const builtOnChainTransaction = onChainTransaction.buildTransaction();
		console.log('builtOnChainTransaction');
		console.log(builtOnChainTransaction);

		console.log('onChainTransaction');
		console.log(onChainTransaction);

		console.log('onChainTransaction.getOutputAmount');
		console.log(onChainTransaction.getOutputAmount());

		console.log('onChainTransaction.getInputAmount');
		console.log(onChainTransaction.getInputAmount());

		const settings = entityos.get({scope: '_settings'});
		const blockfrostProjectID = _.get(settings, 'onchain.cardano.blockfrost.projectId');
		const { BlockFrostAPI } = require('@blockfrost/blockfrost-js');
		const blockfrostAPI = new BlockFrostAPI({projectId: blockfrostProjectID, debug: true, version: 0});

		console.log(builtOnChainTransaction)
		const txBuffer = Buffer.from(builtOnChainTransaction.payload, 'hex');

		//console.log(blockfrostAPI.txSubmit);

		if (true)
		{
			blockfrostAPI.txSubmit(txBuffer).then(function (data)
			{
				console.log(data)
				
			})
			.catch(function (error)
			{
				console.log(error)
				entityos.invoke('util-end', {error: error.message})
			});
		}
	});
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SodiumBip32Ed25519 = void 0;
const Bip32_1 = require("../Bip32");
const Ed25519e_1 = require("../Ed25519e");
const libsodium_wrappers_sumo_1 = __importDefault(require("libsodium-wrappers-sumo"));
const EXTENDED_KEY_HEX_LENGTH = 128;
class SodiumBip32Ed25519 {
    constructor() {
    }
    static async create() {
        await libsodium_wrappers_sumo_1.default.ready;
        return Promise.resolve(new SodiumBip32Ed25519());
    }
    fromBip39Entropy(entropy, passphrase) {
        return Bip32_1.Bip32PrivateKey.fromBip39Entropy(entropy, passphrase).hex();
    }
    getPublicKey(privateKey) {
        const key = privateKey.length === EXTENDED_KEY_HEX_LENGTH
            ? Ed25519e_1.Ed25519PrivateKey.fromExtendedHex(privateKey)
            : Ed25519e_1.Ed25519PrivateKey.fromNormalHex(privateKey);
        return key.toPublic().hex();
    }
    getPubKeyHash(publicKey) {
        const pubKey = Ed25519e_1.Ed25519PublicKey.fromHex(publicKey);
        return pubKey.hash().hex();
    }
    getRawPrivateKey(bip32PrivateKey) {
        return Bip32_1.Bip32PrivateKey.fromHex(bip32PrivateKey).toRawKey().hex();
    }
    getRawPublicKey(bip32PublicKey) {
        const pubKey = Bip32_1.Bip32PublicKey.fromHex(bip32PublicKey);
        return pubKey.toRawKey().hex();
    }
    getBip32PublicKey(privateKey) {
        const privKey = Bip32_1.Bip32PrivateKey.fromHex(privateKey);
        return privKey.toPublic().hex();
    }
    derivePrivateKey(parentKey, derivationIndices) {
        const privKey = Bip32_1.Bip32PrivateKey.fromHex(parentKey);
        return privKey.derive(derivationIndices).hex();
    }
    derivePublicKey(parentKey, derivationIndices) {
        const pubKey = Bip32_1.Bip32PublicKey.fromHex(parentKey);
        return pubKey.derive(derivationIndices).hex();
    }
    sign(privateKey, message) {
        const key = privateKey.length === EXTENDED_KEY_HEX_LENGTH
            ? Ed25519e_1.Ed25519PrivateKey.fromExtendedHex(privateKey)
            : Ed25519e_1.Ed25519PrivateKey.fromNormalHex(privateKey);
        return key.sign(message).hex();
    }
    verify(signature, message, publicKey) {
        const key = Ed25519e_1.Ed25519PublicKey.fromHex(publicKey);
        return key.verify(Ed25519e_1.Ed25519Signature.fromHex(signature), message);
    }
}
exports.SodiumBip32Ed25519 = SodiumBip32Ed25519;
//# sourceMappingURL=SodiumBip32Ed25519.js.map
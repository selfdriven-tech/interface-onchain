"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cbor = exports.defaultParseOptions = void 0;
var CborString_1 = require("../CborString/index.js");
var CborObj_1 = require("../CborObj/index.js");
var Constants_1 = require("./Constants/index.js");
var CborBytes_1 = require("../CborObj/CborBytes.js");
var CborText_1 = require("../CborObj/CborText.js");
var CborArray_1 = require("../CborObj/CborArray.js");
var CborMap_1 = require("../CborObj/CborMap.js");
var CborTag_1 = require("../CborObj/CborTag.js");
var CborSimple_1 = require("../CborObj/CborSimple.js");
var CborUInt_1 = require("../CborObj/CborUInt.js");
var CborNegInt_1 = require("../CborObj/CborNegInt.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var BaseCborError_1 = require("../errors/BaseCborError/index.js");
var assert_1 = require("../utils/assert.js");
var LazyCborArray_1 = require("../LazyCborObj/LazyCborArray.js");
var LazyCborMap_1 = require("../LazyCborObj/LazyCborMap.js");
var LazyCborTag_1 = require("../LazyCborObj/LazyCborTag.js");
var errors_1 = require("../errors/index.js");
var max_1 = require("../constants/max.js");
var SubCborRef_1 = require("../SubCborRef.js");
var overwriteSubCborRefBytes_1 = require("./overwriteSubCborRefBytes.js");
/**
 * @private to the module; not needed elsewhere
 */
var CborEncoding = /** @class */ (function () {
    function CborEncoding() {
        this._buff = new Uint8Array(256); // (1 << 8) bytes, 1/4 kB
        this._len = 0;
    }
    Object.defineProperty(CborEncoding.prototype, "bytes", {
        get: function () {
            return Uint8Array.prototype.slice.call(this._buff, 0, this._len);
            // this._buff.slice( 0, this._len );
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborEncoding.prototype, "length", {
        get: function () {
            return this._len;
        },
        enumerable: false,
        configurable: true
    });
    CborEncoding.prototype._prepareAppendOfByteLength = function (l) {
        var requiredLen = this._len + l;
        var newBuffLen = this._buff.byteLength;
        // expand the Uint8Array if needed
        while (newBuffLen < requiredLen) {
            newBuffLen = newBuffLen << 1; // old length * 2
        }
        // copies the old Uint8Array if expanded
        if (newBuffLen !== this._buff.byteLength) {
            var newBuff = new Uint8Array(newBuffLen);
            for (var i = 0; i < this._len; i++) {
                (0, uint8array_utils_1.writeUInt8)(newBuff, (0, uint8array_utils_1.readUInt8)(this._buff, i), i);
            }
            this._buff = newBuff;
        }
    };
    CborEncoding.prototype._commitAppendOfByteLength = function (l) {
        this._len += l;
    };
    CborEncoding.prototype.appendRawBytes = function (bytes) {
        this._prepareAppendOfByteLength(bytes.length);
        this._buff.set(bytes, this._len);
        this._commitAppendOfByteLength(bytes.length);
    };
    CborEncoding.prototype.appendUInt8 = function (uint8) {
        (0, assert_1.assert)(uint8 >= 0 && uint8 <= 255 &&
            uint8 === Math.round(uint8), "expected a byte; got: " + uint8);
        this._prepareAppendOfByteLength(1);
        (0, uint8array_utils_1.writeUInt8)(this._buff, uint8, this._len);
        this._commitAppendOfByteLength(1);
    };
    CborEncoding.prototype.appendUInt16 = function (uint16) {
        (0, assert_1.assert)(uint16 >= 0 && uint16 <= 65535 &&
            uint16 === Math.round(uint16), "expected two bytes; got: " + uint16);
        this._prepareAppendOfByteLength(2);
        (0, uint8array_utils_1.writeUInt16BE)(this._buff, uint16, this._len);
        this._commitAppendOfByteLength(2);
    };
    CborEncoding.prototype.appendUInt32 = function (uint32) {
        (0, assert_1.assert)(uint32 >= 0 && uint32 <= 4294967295 &&
            uint32 === Math.round(uint32), "expected 4 bytes; got: " + uint32);
        this._prepareAppendOfByteLength(4);
        (0, uint8array_utils_1.writeUInt32BE)(this._buff, uint32, this._len);
        this._commitAppendOfByteLength(4);
    };
    CborEncoding.prototype.appendUInt64 = function (uint64) {
        (0, assert_1.assert)(typeof uint64 === "bigint" &&
            uint64 >= BigInt(0) && uint64 <= BigInt("0b" + "11111111".repeat(8)), "expected 8 bytes; got: " + uint64);
        this._prepareAppendOfByteLength(8);
        (0, uint8array_utils_1.writeBigUInt64BE)(this._buff, uint64, this._len);
        this._commitAppendOfByteLength(8);
    };
    CborEncoding.prototype.appendFloat64 = function (float64) {
        (0, assert_1.assert)(typeof float64 === "number", "expected 8 bytes; got: " + float64);
        this._prepareAppendOfByteLength(8);
        (0, uint8array_utils_1.writeFloat64BE)(this._buff, float64, this._len);
        this._commitAppendOfByteLength(8);
    };
    CborEncoding.prototype.appendTypeAndLength = function (cborType, length, addInfos) {
        (0, assert_1.assert)((0, Constants_1.isMajorTypeTag)(cborType), "passed tag is not a valid major cbor type");
        (0, assert_1.assert)((typeof length === "number" || typeof length === "bigint") &&
            length >= 0, "invalid length");
        if (length > max_1.MAX_4_BYTES || addInfos === 27) {
            if (typeof length === "number")
                length = BigInt(length);
            this.appendUInt8((cborType << 5) | 27 /*expect_uint64*/);
            this.appendUInt64(length);
            return;
        }
        if (typeof length === "bigint")
            length = Number(length);
        var specifcAddInfos = typeof addInfos === "number" && addInfos >= 24 && addInfos <= 27;
        if (length < 24 &&
            !specifcAddInfos // use the specified addInfos if any
        ) {
            this.appendUInt8((cborType << 5) | length);
        }
        else if (length < max_1.OVERFLOW_1_BYTE &&
            (!specifcAddInfos ||
                addInfos === 24)) {
            this.appendUInt8((cborType << 5) | 24);
            this.appendUInt8(length);
        }
        else if (length < max_1.OVERFLOW_2_BYTES &&
            (!specifcAddInfos ||
                addInfos === 25)) {
            this.appendUInt8((cborType << 5) | 25);
            this.appendUInt16(length);
        }
        else /*
        if (
            length < 0x100000000 &&
            (
                !specifcAddInfos ||
                addInfos === 26
            )
        ) //*/ {
            this.appendUInt8((cborType << 5) | 26);
            this.appendUInt32(length);
        }
    };
    CborEncoding.prototype.appendCborObjEncoding = function (cObj) {
        (0, assert_1.assert)((0, CborObj_1.isCborObj)(cObj), "expected 'CborObj' strict instance; got: " + cObj);
        var startOffset = this.length;
        if (cObj instanceof CborUInt_1.CborUInt) {
            (0, assert_1.assert)(cObj.num >= BigInt(0), "encoding invalid unsigned integer as CBOR");
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (cObj.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this.appendCborObjEncoding(new CborTag_1.CborTag(2, cObj.bigNumEncoding));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            var n = cObj.num;
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (n > max_1.maxBigInt) {
                console.dir(cObj, { depth: Infinity });
                console.warn("big positive int encountered but `bigNumEncoding` is not set; " +
                    "you should see the value causing this problem in the console; " +
                    "please report this issue at https://github.com/HarmonicLabs/cbor/issues");
                this.appendCborObjEncoding(CborUInt_1.CborUInt.bigNum(n));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            // else
            this.appendTypeAndLength(Constants_1.MajorType.unsigned, cObj.num, cObj.addInfos);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborNegInt_1.CborNegInt) {
            (0, assert_1.assert)(cObj.num < BigInt(0), "encoding invalid negative integer as CBOR");
            if (cObj.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this.appendCborObjEncoding(new CborTag_1.CborTag(3, cObj.bigNumEncoding));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            var n = cObj.num;
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (n < max_1.minBigInt) {
                console.dir(cObj, { depth: Infinity });
                console.warn("big negative int encountered but `bigNumEncoding` is not set; " +
                    "you should see the value causing this problem in the console; " +
                    "please report this issue at https://github.com/HarmonicLabs/cbor/issues");
                this.appendCborObjEncoding(CborNegInt_1.CborNegInt.bigNum(n));
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            // else
            this.appendTypeAndLength(Constants_1.MajorType.negative, -(n + BigInt(1)), cObj.addInfos);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborBytes_1.CborBytes) {
            // if( cObj.isDefiniteLength )
            if (cObj.chunks instanceof Uint8Array) {
                var bs = cObj.chunks;
                this.appendTypeAndLength(Constants_1.MajorType.bytes, bs.length, cObj.addInfos);
                this.appendRawBytes(bs);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            else {
                var chunks = cObj.chunks;
                var nChunks = chunks.length;
                this.appendUInt8((Constants_1.MajorType.bytes << 5) | 31);
                for (var i = 0; i < nChunks; i++) {
                    this.appendCborObjEncoding(chunks[i]);
                }
                this.appendUInt8(255); // break
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
        }
        if (cObj instanceof CborText_1.CborText) {
            // if( cObj.isDefiniteLength )
            if (typeof cObj.chunks === "string") {
                var bs = (0, uint8array_utils_1.fromUtf8)(cObj.text);
                this.appendTypeAndLength(Constants_1.MajorType.text, bs.length, cObj.addInfos);
                this.appendRawBytes(bs);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            else {
                var chunks = cObj.chunks;
                var nChunks = chunks.length;
                this.appendUInt8((Constants_1.MajorType.text << 5) | 31);
                for (var i = 0; i < nChunks; i++) {
                    this.appendCborObjEncoding(chunks[i]);
                }
                this.appendUInt8(255); // break
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborArray_1.CborArray) {
            var arr = cObj.array;
            var arrLen = arr.length;
            if (cObj.indefinite)
                this.appendUInt8(0x9f);
            else
                this.appendTypeAndLength(Constants_1.MajorType.array, arrLen, cObj.addInfos);
            for (var i = 0; i < arrLen; i++) {
                this.appendCborObjEncoding(arr[i]);
            }
            if (cObj.indefinite)
                this.appendUInt8(0xff);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborMap_1.CborMap) {
            var map = cObj.map;
            if (cObj.indefinite)
                this.appendUInt8(0xbf);
            else
                this.appendTypeAndLength(Constants_1.MajorType.map, map.length, cObj.addInfos);
            for (var i = 0; i < map.length; i++) {
                this.appendCborObjEncoding(map[i].k);
                this.appendCborObjEncoding(map[i].v);
            }
            if (cObj.indefinite)
                this.appendUInt8(0xff);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborTag_1.CborTag) {
            this.appendTypeAndLength(Constants_1.MajorType.tag, cObj.tag);
            this.appendCborObjEncoding(cObj.data);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        if (cObj instanceof CborSimple_1.CborSimple) {
            var simpValue = cObj.simple;
            if (simpValue === false) {
                this.appendUInt8(0xf4); // major type 6 (tag) | 20
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === true) {
                this.appendUInt8(0xf5); // major type 6 (tag) | 21
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === null) {
                this.appendUInt8(0xf6); // major type 6 (tag) | 22
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (simpValue === undefined) {
                this.appendUInt8(0xf7); // major type 6 (tag) | 23
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            if (cObj.numAs === "simple" &&
                simpValue >= 0 && simpValue <= 255 &&
                simpValue === Math.round(simpValue)) {
                this.appendTypeAndLength(Constants_1.MajorType.float_or_simple, simpValue);
                return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                    _bytes: this._buff,
                    start: startOffset,
                    end: this.length
                });
            }
            this.appendUInt8(0xfb); // (MajorType.float_or_simple << 5) | 27 (double precidison float)
            this.appendFloat64(simpValue);
            return cObj.subCborRef = new SubCborRef_1.SubCborRef({
                _bytes: this._buff,
                start: startOffset,
                end: this.length
            });
        }
        throw new BaseCborError_1.BaseCborError("'CborEncoding.appendCborObjEncoding' did not match any possible 'CborObj'");
    };
    return CborEncoding;
}());
exports.defaultParseOptions = Object.freeze({ keepRef: true });
/**
 * static class that allows CBOR encoding and decoding
 *
 * >**_NOTE:_** some tags that are not defined in the proper CBOR specification are automaticaly treated as PlutusData
 */
var Cbor = /** @class */ (function () {
    function Cbor() {
    }
    ; // static class, working as namespace
    Cbor.encode = function (cborObj) {
        var encoded = new CborEncoding();
        encoded.appendCborObjEncoding(cborObj);
        // .bytes is a getter, call once
        var bytes = encoded.bytes;
        // point the sub cbor refs to the final bytes
        // (forget intermediate results)
        (0, overwriteSubCborRefBytes_1.overwriteSubCborRefBytes)(cborObj, bytes);
        return new CborString_1.CborString(bytes);
    };
    Cbor.parse = function (cbor, parseOpts) {
        if (parseOpts === void 0) { parseOpts = exports.defaultParseOptions; }
        return Cbor.parseWithOffset(cbor, parseOpts).parsed;
    };
    Cbor.parseWithOffset = function (cbor, parseOpts) {
        var _a;
        if (parseOpts === void 0) { parseOpts = exports.defaultParseOptions; }
        if (typeof cbor === "string")
            cbor = (0, uint8array_utils_1.fromHex)(cbor);
        (0, assert_1.assert)((cbor instanceof Uint8Array) || cbor instanceof CborString_1.CborString, "in 'Cbor.parse' expected an instance of 'CborString' or a 'Uint8Array' as input; got: " + cbor);
        var bytes = cbor instanceof CborString_1.CborString ?
            cbor.toBuffer() :
            cbor;
        var keepRef = Boolean((_a = parseOpts.keepRef) !== null && _a !== void 0 ? _a : exports.defaultParseOptions.keepRef);
        /**
         * number of bytes red
         * */
        var offset = 0;
        var getSubCborRef = (keepRef ?
            function (startOffset) { return new SubCborRef_1.SubCborRef({
                _bytes: bytes,
                start: startOffset,
                end: offset
            }); }
            : function (_) { return undefined; });
        function incrementOffsetBy(l) {
            offset += l;
        }
        function getBytesOfLength(l) {
            if (bytes.length < offset + l)
                throw new errors_1.CborParseError("not enoug bytes; missing at least " +
                    ((offset + l) - bytes.length) + " bytes");
            incrementOffsetBy(l);
            return bytes.slice(offset - l, // offset has been incremented prior reading
            offset);
        }
        function getUInt8() {
            incrementOffsetBy(1);
            return (0, uint8array_utils_1.readUInt8)(bytes, offset - 1 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt16() {
            incrementOffsetBy(2);
            return (0, uint8array_utils_1.readUInt16BE)(bytes, offset - 2 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt32() {
            incrementOffsetBy(4);
            return (0, uint8array_utils_1.readUInt32BE)(bytes, offset - 4 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt64() {
            incrementOffsetBy(8);
            return (0, uint8array_utils_1.readBigUInt64BE)(bytes, offset - 8 // offset has been incremented prior reading
            );
        }
        ;
        function getFloat16() {
            // increments the offset here
            var floatBits = getUInt16();
            var tempArrayBuffer = new ArrayBuffer(4);
            var tempDataView = new DataView(tempArrayBuffer);
            var sign = floatBits & 32768;
            var exponent = floatBits & 31744;
            var fraction = floatBits & 1023;
            if (exponent === 0x7c00)
                exponent = 0xff << 10;
            else if (exponent !== 0)
                exponent += (127 - 15) << 10;
            else if (fraction !== 0)
                return new CborSimple_1.CborSimple((sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8, "float");
            tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
            return new CborSimple_1.CborSimple(tempDataView.getFloat32(0), "float");
        }
        function getFloat32() {
            incrementOffsetBy(4);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat32BE)(bytes, offset - 4 // offset has been incremented prior reading
            ), "float");
        }
        function getFloat64() {
            incrementOffsetBy(8);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat64BE)(bytes, offset - 8 // offset has been incremented prior reading
            ), "float");
        }
        /**
         *  if the next byte is a break, it increments the offset and returns true
         *  otherwise returns false without side effects
         */
        function skipBreak() {
            if ((0, uint8array_utils_1.readUInt8)(bytes, offset) !== 0xff)
                return false;
            incrementOffsetBy(1);
            return true;
        }
        /*
        function skipBreak(): boolean
        {
            const isBreak = readUInt8( bytes, offset ) === 0xff;
            if( isBreak ) incrementOffsetBy( 1 );
            return isBreak;
        }
        */
        function getLength(addInfos) {
            if (addInfos < 24)
                return BigInt(addInfos);
            if (addInfos === 24)
                return BigInt(getUInt8());
            if (addInfos === 25)
                return BigInt(getUInt16());
            if (addInfos === 26)
                return BigInt(getUInt32());
            if (addInfos === 27)
                return getUInt64();
            if (addInfos === 31)
                return BigInt(-1); // indefinite length element follows
            throw new BaseCborError_1.BaseCborError("Invalid length encoding while parsing CBOR");
        }
        /*
        function getIndefiniteElemLengthOfType( majorType: MajorType ): bigint
        {
            const headerByte = getUInt8();

            if( headerByte === 0xff ) // break indefinite
                return BigInt( -1 );
            
            const elemLength = getLength( headerByte & 0b000_11111 );

            if( elemLength <  0 || (headerByte >> 5 !== majorType ) )
                throw new BaseCborError( "unexpected nested indefinite length element" );

            return elemLength;
        }
        //*/
        function getTextOfLength(l) {
            // increments offset while getting the bytes
            return (0, uint8array_utils_1.toUtf8)(getBytesOfLength(l));
        }
        function parseCborObj() {
            var startOffset = offset;
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25)
                    return getFloat16();
                if (addInfos === 26)
                    return getFloat32();
                if (addInfos === 27)
                    return getFloat64();
            }
            var length = getLength(addInfos);
            if (length < 0 &&
                (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch (major) {
                case Constants_1.MajorType.unsigned: {
                    return new CborUInt_1.CborUInt(length, addInfos, undefined, // bigNumEncoding
                    getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.negative: {
                    return new CborNegInt_1.CborNegInt(-BigInt(1) - length, addInfos, undefined, // bigNumEncoding
                    getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.bytes: {
                    // data in UPLC v1.*.* serializes as indefinite length
                    // indefinie length
                    if (length < 0) {
                        var chunks = [];
                        var elem = void 0;
                        while (!skipBreak()) {
                            elem = parseCborObj();
                            if (!(elem instanceof CborBytes_1.CborBytes)) {
                                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length bytes");
                            }
                            chunks.push(elem);
                        }
                        return new CborBytes_1.CborBytes(chunks, addInfos, getSubCborRef(startOffset));
                    }
                    // definite length
                    return new CborBytes_1.CborBytes(getBytesOfLength(Number(length)), addInfos, getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.text: {
                    if (length < 0) // indefinite length
                     {
                        var chunks = [];
                        var elem = void 0;
                        while (!skipBreak()) {
                            elem = parseCborObj();
                            if (!(elem instanceof CborText_1.CborText)) {
                                console.dir(elem, { depth: Infinity });
                                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length text");
                            }
                            chunks.push(elem);
                        }
                        return new CborText_1.CborText(chunks, addInfos, getSubCborRef(startOffset));
                    }
                    return new CborText_1.CborText(getTextOfLength(Number(length)), addInfos, getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.array: {
                    var arrOfCbors = void 0;
                    if (length < 0) {
                        arrOfCbors = [];
                        while (!skipBreak()) {
                            arrOfCbors.push(parseCborObj());
                        }
                    }
                    else {
                        arrOfCbors = new Array(Number(length));
                        for (var i = 0; i < length; i++) {
                            arrOfCbors[i] = parseCborObj();
                        }
                    }
                    return new CborArray_1.CborArray(arrOfCbors, { indefinite: length < 0, addInfos: addInfos }, getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.map: {
                    var entries = void 0;
                    if (length < 0) {
                        entries = [];
                        while (!skipBreak()) {
                            entries.push({
                                k: parseCborObj(),
                                v: parseCborObj()
                            });
                        }
                    }
                    else {
                        entries = new Array(Number(length));
                        for (var i = 0; i < length; i++) {
                            entries[i] = {
                                k: parseCborObj(),
                                v: parseCborObj()
                            };
                        }
                    }
                    return new CborMap_1.CborMap(entries, { indefinite: length < 0, addInfos: addInfos }, getSubCborRef(startOffset));
                }
                case Constants_1.MajorType.tag: {
                    var l = Number(length);
                    var data = parseCborObj();
                    // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
                    if (l === 2 && data instanceof CborBytes_1.CborBytes) {
                        return CborUInt_1.CborUInt.bigNum(data, getSubCborRef(startOffset));
                    }
                    // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
                    else if (l === 3 && data instanceof CborBytes_1.CborBytes) {
                        return CborNegInt_1.CborNegInt.bigNum(data, getSubCborRef(startOffset));
                    }
                    // else just tag
                    return new CborTag_1.CborTag(l, data);
                }
                case Constants_1.MajorType.float_or_simple: {
                    var nLen = Number(length);
                    var subCborRef = getSubCborRef(startOffset);
                    if (nLen === 20)
                        return new CborSimple_1.CborSimple(false, undefined, subCborRef); // 0xf4
                    if (nLen === 21)
                        return new CborSimple_1.CborSimple(true, undefined, subCborRef); // 0xf5
                    if (nLen === 22)
                        return new CborSimple_1.CborSimple(null, undefined, subCborRef); // 0xf6
                    if (nLen === 23)
                        return new CborSimple_1.CborSimple(undefined, undefined, subCborRef); // 0xf7
                    // floats handled at the beginning of the function
                    // since length isn't required
                    throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                }
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        return { parsed: parseCborObj(), offset: offset };
    };
    Cbor.parseLazy = function (cbor) {
        return Cbor.parseLazyWithOffset(cbor).parsed;
    };
    Cbor.parseLazyWithOffset = function (cbor) {
        if (typeof cbor === "string")
            cbor = (0, uint8array_utils_1.fromHex)(cbor);
        (0, assert_1.assert)((cbor instanceof Uint8Array) || CborString_1.CborString.isStrictInstance(cbor), "in 'Cbor.parse' expected an instance of 'CborString' or a 'Uint8Array' as input; got: " + cbor);
        var bytes = cbor instanceof CborString_1.CborString ?
            cbor.toBuffer() :
            cbor;
        /**
         * number of bytes red
         * */
        var offset = 0;
        function incrementOffsetBy(l) {
            offset += l;
        }
        function getBytesOfLength(l) {
            if (bytes.length < offset + l)
                throw new errors_1.CborParseError("not enoug bytes; missing at least " +
                    ((offset + l) - bytes.length) + " bytes");
            incrementOffsetBy(l);
            return bytes.slice(offset - l, // offset has been incremented prior reading
            offset);
        }
        function getUInt8() {
            incrementOffsetBy(1);
            return (0, uint8array_utils_1.readUInt8)(bytes, offset - 1 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt16() {
            incrementOffsetBy(2);
            return (0, uint8array_utils_1.readUInt16BE)(bytes, offset - 2 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt32() {
            incrementOffsetBy(4);
            return (0, uint8array_utils_1.readUInt32BE)(bytes, offset - 4 // offset has been incremented prior reading
            );
        }
        ;
        function getUInt64() {
            incrementOffsetBy(8);
            return (0, uint8array_utils_1.readBigUInt64BE)(bytes, offset - 8 // offset has been incremented prior reading
            );
        }
        ;
        function getFloat16() {
            // increments the offset here
            var floatBits = getUInt16();
            var tempArrayBuffer = new ArrayBuffer(4);
            var tempDataView = new DataView(tempArrayBuffer);
            var sign = floatBits & 32768;
            var exponent = floatBits & 31744;
            var fraction = floatBits & 1023;
            if (exponent === 0x7c00)
                exponent = 0xff << 10;
            else if (exponent !== 0)
                exponent += (127 - 15) << 10;
            else if (fraction !== 0)
                return new CborSimple_1.CborSimple((sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8, "float");
            tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
            return new CborSimple_1.CborSimple(tempDataView.getFloat32(0), "float");
        }
        function getFloat32() {
            incrementOffsetBy(4);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat32BE)(bytes, offset - 4 // offset has been incremented prior reading
            ), "float");
        }
        function getFloat64() {
            incrementOffsetBy(8);
            return new CborSimple_1.CborSimple((0, uint8array_utils_1.readFloat64BE)(bytes, offset - 8 // offset has been incremented prior reading
            ), "float");
        }
        function skipBreak() {
            if ((0, uint8array_utils_1.readUInt8)(bytes, offset) !== 0xff)
                return false;
            incrementOffsetBy(1);
            return true;
        }
        function getLength(addInfos) {
            if (addInfos < 24)
                return BigInt(addInfos);
            if (addInfos === 24)
                return BigInt(getUInt8());
            if (addInfos === 25)
                return BigInt(getUInt16());
            if (addInfos === 26)
                return BigInt(getUInt32());
            if (addInfos === 27)
                return getUInt64();
            if (addInfos === 31)
                return BigInt(-1); // indefinite length element follows
            throw new BaseCborError_1.BaseCborError("Invalid length encoding while parsing CBOR");
        }
        function getIndefiniteElemLengthOfType(majorType) {
            var headerByte = getUInt8();
            if (headerByte === 0xff) // break indefinite
                return BigInt(-1);
            var elemLength = getLength(headerByte & 31);
            if (elemLength < 0 || (headerByte >> 5 !== majorType))
                throw new BaseCborError_1.BaseCborError("unexpected nested indefinite length element");
            return elemLength;
        }
        function getTextOfLength(l) {
            // increments offset while getting the bytes
            return (0, uint8array_utils_1.toUtf8)(getBytesOfLength(l));
        }
        function getNextElemBytes() {
            var elemStart = offset;
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25)
                    return bytes.slice(elemStart, elemStart + 2);
                if (addInfos === 26)
                    return bytes.slice(elemStart, elemStart + 3);
                if (addInfos === 27)
                    return bytes.slice(elemStart, elemStart + 5);
            }
            var preLenOffset = offset;
            var length = getLength(addInfos);
            var postLenOffset = offset;
            if (length < 0 &&
                (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch (major) {
                case Constants_1.MajorType.unsigned: return bytes.slice(elemStart, postLenOffset);
                case Constants_1.MajorType.negative: return bytes.slice(elemStart, postLenOffset);
                case Constants_1.MajorType.bytes:
                    if (length < 0) // data in UPLC v1.*.* serializes as indefinite length
                     {
                        var elementLength = void 0;
                        while ((elementLength = getIndefiniteElemLengthOfType(major)) >= 0) {
                            // this operation is done when calling
                            // `getBytesOfLength( Number( elementLength )`
                            /// in the non-lazy verision
                            incrementOffsetBy(Number(elementLength));
                        }
                        return bytes.slice(elemStart, offset);
                    }
                    // definite length
                    // void getBytesOfLength( Number( length ) )
                    incrementOffsetBy(Number(length)); // this is the only part we need of the above function
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.text:
                    if (length < 0) // indefinite length
                     {
                        var str = "";
                        var l = 0;
                        while ((l = Number(getIndefiniteElemLengthOfType(Constants_1.MajorType.text))) >= 0) {
                            // str += getTextOfLength( l );
                            incrementOffsetBy(l);
                        }
                        return bytes.slice(elemStart, offset);
                    }
                    // void getTextOfLength( Number( length ) );
                    incrementOffsetBy(Number(length)); // this is the only part we need of the above function
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.array:
                    if (length < 0) {
                        while (!skipBreak()) {
                            void getNextElemBytes();
                        }
                    }
                    else {
                        for (var i = 0; i < length; i++) {
                            void getNextElemBytes();
                        }
                    }
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.map:
                    if (length < 0) {
                        while (!skipBreak()) {
                            void getNextElemBytes();
                            void getNextElemBytes();
                        }
                    }
                    else {
                        for (var i = 0; i < length; i++) {
                            void getNextElemBytes();
                            void getNextElemBytes();
                        }
                    }
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.tag:
                    void getNextElemBytes();
                    return bytes.slice(elemStart, offset);
                case Constants_1.MajorType.float_or_simple:
                    var nLen = Number(length);
                    if (nLen === 20)
                        return bytes.slice(elemStart, offset); // 0xf4
                    if (nLen === 21)
                        return bytes.slice(elemStart, offset); // 0xf5
                    if (nLen === 22)
                        return bytes.slice(elemStart, offset); // 0xf6
                    if (nLen === 23)
                        return bytes.slice(elemStart, offset); // 0xf7
                    // floats handled at the beginning of the function
                    // since length isn't required
                    throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        function parseCborObj() {
            var headerByte = getUInt8();
            var major = headerByte >> 5;
            var addInfos = headerByte & 31;
            if (major === Constants_1.MajorType.float_or_simple) {
                if (addInfos === 25)
                    return getFloat16();
                if (addInfos === 26)
                    return getFloat32();
                if (addInfos === 27)
                    return getFloat64();
            }
            var length = getLength(addInfos);
            if (length < 0 &&
                (major < 2 || major > 6)) {
                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing CBOR");
            }
            switch (major) {
                case Constants_1.MajorType.unsigned: return new CborUInt_1.CborUInt(length, addInfos);
                case Constants_1.MajorType.negative: {
                    return new CborNegInt_1.CborNegInt(-BigInt(1) - length, addInfos);
                }
                case Constants_1.MajorType.bytes: {
                    // data in UPLC v1.*.* serializes as indefinite length
                    // indefinie length
                    if (length < 0) {
                        var chunks = [];
                        var elem = void 0;
                        while (!skipBreak()) {
                            elem = parseCborObj();
                            if (!(elem instanceof CborBytes_1.CborBytes)) {
                                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length bytes");
                            }
                            chunks.push(elem);
                        }
                        return new CborBytes_1.CborBytes(chunks, addInfos);
                    }
                    // definite length
                    return new CborBytes_1.CborBytes(getBytesOfLength(Number(length)), addInfos);
                }
                case Constants_1.MajorType.text: {
                    if (length < 0) // indefinite length
                     {
                        var chunks = [];
                        var elem = void 0;
                        while (!skipBreak()) {
                            elem = parseCborObj();
                            if (!(elem instanceof CborText_1.CborText)) {
                                console.dir(elem, { depth: Infinity });
                                throw new BaseCborError_1.BaseCborError("unexpected indefinite length element while parsing indefinite length text");
                            }
                            chunks.push(elem);
                        }
                        return new CborText_1.CborText(chunks, addInfos);
                    }
                    return new CborText_1.CborText(getTextOfLength(Number(length)), addInfos);
                }
                case Constants_1.MajorType.array: {
                    if (length < 0) {
                        var arr = [];
                        while (!skipBreak()) {
                            arr.push(getNextElemBytes());
                        }
                        return new LazyCborArray_1.LazyCborArray(arr, { indefinite: true, addInfos: addInfos });
                    }
                    else {
                        var arr = new Array(Number(length));
                        for (var i = 0; i < length; i++) {
                            arr[i] = getNextElemBytes();
                        }
                        return new LazyCborArray_1.LazyCborArray(arr, { indefinite: false, addInfos: addInfos });
                    }
                }
                case Constants_1.MajorType.map: {
                    if (length < 0) {
                        var entries = [];
                        while (!skipBreak()) {
                            entries.push({
                                k: getNextElemBytes(),
                                v: getNextElemBytes()
                            });
                        }
                        return new LazyCborMap_1.LazyCborMap(entries, { indefinite: true, addInfos: addInfos });
                    }
                    else {
                        var entries = new Array(Number(length));
                        for (var i = 0; i < length; i++) {
                            entries[i] = {
                                k: getNextElemBytes(),
                                v: getNextElemBytes()
                            };
                        }
                        return new LazyCborMap_1.LazyCborMap(entries, { indefinite: true, addInfos: addInfos });
                    }
                }
                case Constants_1.MajorType.tag:
                    return new LazyCborTag_1.LazyCborTag(Number(length), parseCborObj());
                case Constants_1.MajorType.float_or_simple:
                    var nLen = Number(length);
                    if (nLen === 20)
                        return new CborSimple_1.CborSimple(false); // 0xf4
                    if (nLen === 21)
                        return new CborSimple_1.CborSimple(true); // 0xf5
                    if (nLen === 22)
                        return new CborSimple_1.CborSimple(null); // 0xf6
                    if (nLen === 23)
                        return new CborSimple_1.CborSimple(undefined); // 0xf7
                    // floats handled at the beginning of the function
                    // since length isn't required
                    throw new BaseCborError_1.BaseCborError("unrecognized simple value");
                default:
                    throw new BaseCborError_1.BaseCborError("unrecognized majorType: " + major);
            }
        }
        return { parsed: parseCborObj(), offset: offset };
    };
    return Cbor;
}());
exports.Cbor = Cbor;

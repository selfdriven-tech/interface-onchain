"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CborNegInt = exports.isRawCborNegative = void 0;
var assert_1 = require("../utils/assert.js");
var CborBytes_1 = require("./CborBytes.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var max_1 = require("../constants/max.js");
var headerFollowingToAddInfos_1 = require("../utils/headerFollowingToAddInfos.js");
function isRawCborNegative(neg) {
    if (typeof neg !== "object" || neg === null)
        return false;
    var keys = Object.keys(neg);
    return (keys.includes("neg") &&
        typeof neg.neg === "bigint" &&
        neg.neg < 0);
}
exports.isRawCborNegative = isRawCborNegative;
var CborNegInt = /** @class */ (function () {
    function CborNegInt(neg, addInfos, bigNumEncoding, subCborRef) {
        this.subCborRef = subCborRef;
        if (typeof neg === "number")
            neg = BigInt(neg);
        this.num = neg;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(neg);
        // this.followingHeaderBytes = followingHeaderBytes;
        if (bigNumEncoding instanceof CborBytes_1.CborBytes)
            this.bigNumEncoding = bigNumEncoding;
        else
            this.bigNumEncoding = undefined;
    }
    Object.defineProperty(CborNegInt.prototype, "num", {
        get: function () {
            if (this.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this._num = -(BigInt("0x" +
                    (0, uint8array_utils_1.toHex)(this.bigNumEncoding.bytes)) + BigInt(1));
            }
            return this._num;
        },
        set: function (neg) {
            (0, assert_1.assert)(neg < 0, "neg CBOR numbers must be less than 0; got: " + neg);
            neg = BigInt(neg);
            // https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
            if (neg < max_1.minBigInt) {
                neg = BigInt(-1) - BigInt(neg);
                var hex = neg.toString(16);
                if ((hex.length % 2) === 1)
                    hex = "0" + hex;
                this.bigNumEncoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
            }
            this._num = BigInt(neg);
        },
        enumerable: false,
        configurable: true
    });
    CborNegInt.prototype.isBigNum = function () {
        return this.bigNumEncoding instanceof CborBytes_1.CborBytes;
    };
    CborNegInt.bigNum = function (encoding, subCborRef) {
        var n = undefined;
        if (!(encoding instanceof CborBytes_1.CborBytes)) {
            encoding = BigInt(-1) - BigInt(encoding);
            n = encoding;
            var hex = encoding.toString(16);
            if ((hex.length % 2) === 1)
                hex = "0" + hex;
            encoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
        }
        else {
            n = BigInt(-1) - BigInt("0x" + (0, uint8array_utils_1.toHex)(encoding.bytes));
        }
        return new CborNegInt(n, 0, encoding, subCborRef);
    };
    CborNegInt.prototype.toRawObj = function () {
        return {
            neg: this.num
        };
    };
    CborNegInt.prototype.clone = function () {
        var _a, _b;
        return new CborNegInt(this.num, this.addInfos, (_a = this.bigNumEncoding) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.subCborRef) === null || _b === void 0 ? void 0 : _b.clone());
    };
    return CborNegInt;
}());
exports.CborNegInt = CborNegInt;

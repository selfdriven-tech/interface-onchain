"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CborUInt = exports.isRawCborUnsigned = void 0;
var assert_1 = require("../utils/assert.js");
var CborBytes_1 = require("./CborBytes.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var max_1 = require("../constants/max.js");
var headerFollowingToAddInfos_1 = require("../utils/headerFollowingToAddInfos.js");
function isRawCborUnsigned(unsign) {
    if (typeof unsign !== "object" || unsign === null)
        return false;
    var keys = Object.keys(unsign);
    return (keys.includes("uint") &&
        typeof unsign.uint === "bigint" &&
        unsign.uint >= 0);
}
exports.isRawCborUnsigned = isRawCborUnsigned;
var CborUInt = /** @class */ (function () {
    function CborUInt(uint, addInfos, bigNumEncoding, subCborRef) {
        this.subCborRef = subCborRef;
        this.num = uint;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(uint);
        if (bigNumEncoding instanceof CborBytes_1.CborBytes)
            this.bigNumEncoding = bigNumEncoding;
        else
            this.bigNumEncoding = undefined;
    }
    Object.defineProperty(CborUInt.prototype, "num", {
        get: function () {
            if (this.bigNumEncoding instanceof CborBytes_1.CborBytes) {
                this._num = BigInt("0x" +
                    (0, uint8array_utils_1.toHex)(this.bigNumEncoding.bytes));
            }
            return this._num;
        },
        set: function (uint) {
            (0, assert_1.assert)(uint >= BigInt(0), "uint CBOR numbers must be greater or equal 0; got: " + uint);
            uint = BigInt(uint);
            if (uint > max_1.maxBigInt) {
                var hex = uint.toString(16);
                if ((hex.length % 2) === 1)
                    hex = "0" + hex;
                this.bigNumEncoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
            }
            this._num = uint;
        },
        enumerable: false,
        configurable: true
    });
    CborUInt.prototype.isBigNum = function () {
        return this.bigNumEncoding instanceof CborBytes_1.CborBytes;
    };
    CborUInt.bigNum = function (encoding, subCborRef) {
        var n = undefined;
        if (!(encoding instanceof CborBytes_1.CborBytes)) {
            encoding = BigInt(encoding);
            n = encoding;
            var hex = encoding.toString(16);
            if ((hex.length % 2) === 1)
                hex = "0" + hex;
            encoding = new CborBytes_1.CborBytes((0, uint8array_utils_1.fromHex)(hex));
        }
        else {
            n = BigInt("0x" + (0, uint8array_utils_1.toHex)(encoding.bytes));
        }
        return new CborUInt(n, 0, encoding, subCborRef);
    };
    CborUInt.prototype.toRawObj = function () {
        return {
            uint: this.num
        };
    };
    CborUInt.prototype.clone = function () {
        var _a, _b;
        return new CborUInt(this.num, this.addInfos, (_a = this.bigNumEncoding) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.subCborRef) === null || _b === void 0 ? void 0 : _b.clone());
    };
    return CborUInt;
}());
exports.CborUInt = CborUInt;
